<html>
<head>
<title>cmd.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cmd.py</font>
</center></td></tr></table>
<pre><span class="s0"># cmd.py</span>
<span class="s0"># Copyright (C) 2008, 2009 Michael Trier (mtrier@gmail.com) and contributors</span>
<span class="s0">#</span>
<span class="s0"># This module is part of GitPython and is released under</span>
<span class="s0"># the BSD License: http://www.opensource.org/licenses/bsd-license.php</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">signal</span>
<span class="s2">from </span><span class="s1">subprocess </span><span class="s2">import </span><span class="s1">call</span><span class="s2">, </span><span class="s1">Popen</span><span class="s2">, </span><span class="s1">PIPE</span><span class="s2">, </span><span class="s1">DEVNULL</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">dedent</span>

<span class="s2">from </span><span class="s1">git.compat </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">defenc</span><span class="s2">,</span>
    <span class="s1">force_bytes</span><span class="s2">,</span>
    <span class="s1">safe_decode</span><span class="s2">,</span>
    <span class="s1">is_posix</span><span class="s2">,</span>
    <span class="s1">is_win</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">git.exc </span><span class="s2">import </span><span class="s1">CommandError</span>
<span class="s2">from </span><span class="s1">git.util </span><span class="s2">import </span><span class="s1">is_cygwin_git</span><span class="s2">, </span><span class="s1">cygpath</span><span class="s2">, </span><span class="s1">expand_path</span><span class="s2">, </span><span class="s1">remove_password_if_present</span>

<span class="s2">from </span><span class="s1">.exc </span><span class="s2">import </span><span class="s1">GitCommandError</span><span class="s2">, </span><span class="s1">GitCommandNotFound</span><span class="s2">, </span><span class="s1">UnsafeOptionError</span><span class="s2">, </span><span class="s1">UnsafeProtocolError</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">LazyMixin</span><span class="s2">,</span>
    <span class="s1">stream_copy</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s0"># typing ---------------------------------------------------------------------------</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">AnyStr</span><span class="s2">,</span>
    <span class="s1">BinaryIO</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">IO</span><span class="s2">,</span>
    <span class="s1">Iterator</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">TextIO</span><span class="s2">,</span>
    <span class="s1">Tuple</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">git.types </span><span class="s2">import </span><span class="s1">PathLike</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">TBD</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">git.repo.base </span><span class="s2">import </span><span class="s1">Repo</span>
    <span class="s2">from </span><span class="s1">git.diff </span><span class="s2">import </span><span class="s1">DiffIndex</span>


<span class="s0"># ---------------------------------------------------------------------------------</span>

<span class="s1">execute_kwargs = {</span>
    <span class="s3">&quot;istream&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;with_extended_output&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;with_exceptions&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;as_process&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;stdout_as_string&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;output_stream&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;with_stdout&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;kill_after_timeout&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;universal_newlines&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;shell&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;env&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;max_chunk_size&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;strip_newline_in_stdout&quot;</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">log = logging.getLogger(__name__)</span>
<span class="s1">log.addHandler(logging.NullHandler())</span>

<span class="s1">__all__ = (</span><span class="s3">&quot;Git&quot;</span><span class="s2">,</span><span class="s1">)</span>


<span class="s0"># ==============================================================================</span>
<span class="s0">## @name Utilities</span>
<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># Documentation</span>
<span class="s0">## @{</span>


<span class="s2">def </span><span class="s1">handle_process_output(</span>
    <span class="s1">process: </span><span class="s3">&quot;Git.AutoInterrupt&quot; </span><span class="s1">| Popen</span><span class="s2">,</span>
    <span class="s1">stdout_handler: Union[</span>
        <span class="s2">None,</span>
        <span class="s1">Callable[[AnyStr]</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">Callable[[List[AnyStr]]</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">Callable[[bytes</span><span class="s2">, </span><span class="s3">&quot;Repo&quot;</span><span class="s2">, </span><span class="s3">&quot;DiffIndex&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">stderr_handler: Union[</span><span class="s2">None, </span><span class="s1">Callable[[AnyStr]</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Callable[[List[AnyStr]]</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">finalizer: Union[</span><span class="s2">None, </span><span class="s1">Callable[[Union[subprocess.Popen</span><span class="s2">, </span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s1">]]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
    <span class="s1">decode_streams: bool = </span><span class="s2">True,</span>
    <span class="s1">kill_after_timeout: Union[</span><span class="s2">None, </span><span class="s1">float] = </span><span class="s2">None,</span>
<span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot;Registers for notifications to learn that process output is ready to read, and dispatches lines to 
    the respective line handlers. 
    This function returns once the finalizer returns 
 
    :return: result of finalizer 
    :param process: subprocess.Popen instance 
    :param stdout_handler: f(stdout_line_string), or None 
    :param stderr_handler: f(stderr_line_string), or None 
    :param finalizer: f(proc) - wait for proc to finish 
    :param decode_streams: 
        Assume stdout/stderr streams are binary and decode them before pushing \ 
        their contents to handlers. 
        Set it to False if `universal_newline == True` (then streams are in text-mode) 
        or if decoding must happen later (i.e. for Diffs). 
    :param kill_after_timeout: 
        float or None, Default = None 
        To specify a timeout in seconds for the git command, after which the process 
        should be killed. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Use 2 &quot;pump&quot; threads and wait for both to finish.</span>
    <span class="s2">def </span><span class="s1">pump_stream(</span>
        <span class="s1">cmdline: List[str]</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">stream: Union[BinaryIO</span><span class="s2">, </span><span class="s1">TextIO]</span><span class="s2">,</span>
        <span class="s1">is_decode: bool</span><span class="s2">,</span>
        <span class="s1">handler: Union[</span><span class="s2">None, </span><span class="s1">Callable[[Union[bytes</span><span class="s2">, </span><span class="s1">str]]</span><span class="s2">, None</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">stream:</span>
                <span class="s2">if </span><span class="s1">handler:</span>
                    <span class="s2">if </span><span class="s1">is_decode:</span>
                        <span class="s2">assert </span><span class="s1">isinstance(line</span><span class="s2">, </span><span class="s1">bytes)</span>
                        <span class="s1">line_str = line.decode(defenc)</span>
                        <span class="s1">handler(line_str)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">handler(line)</span>

        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex:</span>
            <span class="s1">log.error(</span><span class="s3">f&quot;Pumping </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s3">of cmd(</span><span class="s2">{</span><span class="s1">remove_password_if_present(cmdline)</span><span class="s2">}</span><span class="s3">) failed due to: </span><span class="s2">{</span><span class="s1">ex</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s3">&quot;I/O operation on closed file&quot; </span><span class="s2">not in </span><span class="s1">str(ex):</span>
                <span class="s0"># Only reraise if the error was not due to the stream closing</span>
                <span class="s2">raise </span><span class="s1">CommandError([</span><span class="s3">f&quot;&lt;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">-pump&gt;&quot;</span><span class="s1">] + remove_password_if_present(cmdline)</span><span class="s2">, </span><span class="s1">ex) </span><span class="s2">from </span><span class="s1">ex</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">stream.close()</span>

    <span class="s2">if </span><span class="s1">hasattr(process</span><span class="s2">, </span><span class="s3">&quot;proc&quot;</span><span class="s1">):</span>
        <span class="s1">process = cast(</span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s2">, </span><span class="s1">process)</span>
        <span class="s1">cmdline: str | Tuple[str</span><span class="s2">, </span><span class="s1">...] | List[str] = getattr(process.proc</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">p_stdout = process.proc.stdout </span><span class="s2">if </span><span class="s1">process.proc </span><span class="s2">else None</span>
        <span class="s1">p_stderr = process.proc.stderr </span><span class="s2">if </span><span class="s1">process.proc </span><span class="s2">else None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">process = cast(Popen</span><span class="s2">, </span><span class="s1">process)</span>
        <span class="s1">cmdline = getattr(process</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">p_stdout = process.stdout</span>
        <span class="s1">p_stderr = process.stderr</span>

    <span class="s2">if not </span><span class="s1">isinstance(cmdline</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
        <span class="s1">cmdline = cmdline.split()</span>

    <span class="s1">pumps: List[Tuple[str</span><span class="s2">, </span><span class="s1">IO</span><span class="s2">, </span><span class="s1">Callable[...</span><span class="s2">, None</span><span class="s1">] | </span><span class="s2">None</span><span class="s1">]] = []</span>
    <span class="s2">if </span><span class="s1">p_stdout:</span>
        <span class="s1">pumps.append((</span><span class="s3">&quot;stdout&quot;</span><span class="s2">, </span><span class="s1">p_stdout</span><span class="s2">, </span><span class="s1">stdout_handler))</span>
    <span class="s2">if </span><span class="s1">p_stderr:</span>
        <span class="s1">pumps.append((</span><span class="s3">&quot;stderr&quot;</span><span class="s2">, </span><span class="s1">p_stderr</span><span class="s2">, </span><span class="s1">stderr_handler))</span>

    <span class="s1">threads: List[threading.Thread] = []</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">handler </span><span class="s2">in </span><span class="s1">pumps:</span>
        <span class="s1">t = threading.Thread(target=pump_stream</span><span class="s2">, </span><span class="s1">args=(cmdline</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">decode_streams</span><span class="s2">, </span><span class="s1">handler))</span>
        <span class="s1">t.daemon = </span><span class="s2">True</span>
        <span class="s1">t.start()</span>
        <span class="s1">threads.append(t)</span>

    <span class="s0">## FIXME: Why Join??  Will block if `stdin` needs feeding...</span>
    <span class="s0">#</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">threads:</span>
        <span class="s1">t.join(timeout=kill_after_timeout)</span>
        <span class="s2">if </span><span class="s1">t.is_alive():</span>
            <span class="s2">if </span><span class="s1">isinstance(process</span><span class="s2">, </span><span class="s1">Git.AutoInterrupt):</span>
                <span class="s1">process._terminate()</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s0"># Don't want to deal with the other case</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                    <span class="s3">&quot;Thread join() timed out in cmd.handle_process_output().&quot;</span>
                    <span class="s3">f&quot; kill_after_timeout=</span><span class="s2">{</span><span class="s1">kill_after_timeout</span><span class="s2">} </span><span class="s3">seconds&quot;</span>
                <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">stderr_handler:</span>
                <span class="s1">error_str: Union[str</span><span class="s2">, </span><span class="s1">bytes] = (</span>
                    <span class="s3">&quot;error: process killed because it timed out.&quot; f&quot; kill_after_timeout=</span><span class="s2">{</span><span class="s1">kill_after_timeout</span><span class="s2">} </span><span class="s3">seconds&quot;</span>
                <span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">decode_streams </span><span class="s2">and </span><span class="s1">isinstance(p_stderr</span><span class="s2">, </span><span class="s1">BinaryIO):</span>
                    <span class="s0">#  Assume stderr_handler needs binary input</span>
                    <span class="s1">error_str = cast(str</span><span class="s2">, </span><span class="s1">error_str)</span>
                    <span class="s1">error_str = error_str.encode()</span>
                <span class="s0"># We ignore typing on the next line because mypy does not like</span>
                <span class="s0"># the way we inferred that stderr takes str or bytes</span>
                <span class="s1">stderr_handler(error_str)  </span><span class="s0"># type: ignore</span>

    <span class="s2">if </span><span class="s1">finalizer:</span>
        <span class="s2">return </span><span class="s1">finalizer(process)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">dashify(string: str) -&gt; str:</span>
    <span class="s2">return </span><span class="s1">string.replace(</span><span class="s3">&quot;_&quot;</span><span class="s2">, </span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">slots_to_dict(self: object</span><span class="s2">, </span><span class="s1">exclude: Sequence[str] = ()) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">Any]:</span>
    <span class="s2">return </span><span class="s1">{s: getattr(self</span><span class="s2">, </span><span class="s1">s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.__slots__ </span><span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">exclude}</span>


<span class="s2">def </span><span class="s1">dict_to_slots_and__excluded_are_none(self: object</span><span class="s2">, </span><span class="s1">d: Mapping[str</span><span class="s2">, </span><span class="s1">Any]</span><span class="s2">, </span><span class="s1">excluded: Sequence[str] = ()) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">d.items():</span>
        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">excluded:</span>
        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s0">## -- End Utilities -- @}</span>


<span class="s0"># value of Windows process creation flag taken from MSDN</span>
<span class="s1">CREATE_NO_WINDOW = </span><span class="s5">0x08000000</span>

<span class="s0">## CREATE_NEW_PROCESS_GROUP is needed to allow killing it afterwards,</span>
<span class="s0"># see https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal</span>
<span class="s1">PROC_CREATIONFLAGS = (</span>
    <span class="s1">CREATE_NO_WINDOW | subprocess.CREATE_NEW_PROCESS_GROUP </span><span class="s2">if </span><span class="s1">is_win </span><span class="s2">else </span><span class="s5">0  </span><span class="s0"># type: ignore[attr-defined]</span>
<span class="s1">)  </span><span class="s0"># mypy error if not windows</span>


<span class="s2">class </span><span class="s1">Git(LazyMixin):</span>

    <span class="s4">&quot;&quot;&quot; 
    The Git class manages communication with the Git binary. 
 
    It provides a convenient interface to calling the Git binary, such as in:: 
 
     g = Git( git_dir ) 
     g.init()                   # calls 'git init' program 
     rval = g.ls_files()        # calls 'git ls-files' program 
 
    ``Debugging`` 
        Set the GIT_PYTHON_TRACE environment variable print each invocation 
        of the command to stdout. 
        Set its value to 'full' to see details about the returned values. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;_working_dir&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;cat_file_all&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;cat_file_header&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_version_info&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_git_options&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_persistent_git_options&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;_environment&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">_excluded_ = (</span><span class="s3">&quot;cat_file_all&quot;</span><span class="s2">, </span><span class="s3">&quot;cat_file_header&quot;</span><span class="s2">, </span><span class="s3">&quot;_version_info&quot;</span><span class="s1">)</span>

    <span class="s1">re_unsafe_protocol = re.compile(</span><span class="s3">&quot;(.+)::.+&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__getstate__(self) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">Any]:</span>
        <span class="s2">return </span><span class="s1">slots_to_dict(self</span><span class="s2">, </span><span class="s1">exclude=self._excluded_)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">d: Dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">dict_to_slots_and__excluded_are_none(self</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">excluded=self._excluded_)</span>

    <span class="s0"># CONFIGURATION</span>

    <span class="s1">git_exec_name = </span><span class="s3">&quot;git&quot;  </span><span class="s0"># default that should work on linux and windows</span>

    <span class="s0"># Enables debugging of GitPython's git commands</span>
    <span class="s1">GIT_PYTHON_TRACE = os.environ.get(</span><span class="s3">&quot;GIT_PYTHON_TRACE&quot;</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s0"># If True, a shell will be used when executing git commands.</span>
    <span class="s0"># This should only be desirable on Windows, see https://github.com/gitpython-developers/GitPython/pull/126</span>
    <span class="s0"># and check `git/test_repo.py:TestRepo.test_untracked_files()` TC for an example where it is required.</span>
    <span class="s0"># Override this value using `Git.USE_SHELL = True`</span>
    <span class="s1">USE_SHELL = </span><span class="s2">False</span>

    <span class="s0"># Provide the full path to the git executable. Otherwise it assumes git is in the path</span>
    <span class="s1">_git_exec_env_var = </span><span class="s3">&quot;GIT_PYTHON_GIT_EXECUTABLE&quot;</span>
    <span class="s1">_refresh_env_var = </span><span class="s3">&quot;GIT_PYTHON_REFRESH&quot;</span>
    <span class="s1">GIT_PYTHON_GIT_EXECUTABLE = </span><span class="s2">None</span>
    <span class="s0"># note that the git executable is actually found during the refresh step in</span>
    <span class="s0"># the top level __init__</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">refresh(cls</span><span class="s2">, </span><span class="s1">path: Union[</span><span class="s2">None, </span><span class="s1">PathLike] = </span><span class="s2">None</span><span class="s1">) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot;This gets called by the refresh function (see the top level 
        __init__). 
        &quot;&quot;&quot;</span>
        <span class="s0"># discern which path to refresh with</span>
        <span class="s2">if </span><span class="s1">path </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">new_git = os.path.expanduser(path)</span>
            <span class="s1">new_git = os.path.abspath(new_git)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">new_git = os.environ.get(cls._git_exec_env_var</span><span class="s2">, </span><span class="s1">cls.git_exec_name)</span>

        <span class="s0"># keep track of the old and new git executable path</span>
        <span class="s1">old_git = cls.GIT_PYTHON_GIT_EXECUTABLE</span>
        <span class="s1">cls.GIT_PYTHON_GIT_EXECUTABLE = new_git</span>

        <span class="s0"># test if the new git executable path is valid</span>

        <span class="s0"># - a GitCommandNotFound error is spawned by ourselves</span>
        <span class="s0"># - a PermissionError is spawned if the git executable provided</span>
        <span class="s0">#   cannot be executed for whatever reason</span>

        <span class="s1">has_git = </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">cls().version()</span>
            <span class="s1">has_git = </span><span class="s2">True</span>
        <span class="s2">except </span><span class="s1">(GitCommandNotFound</span><span class="s2">, </span><span class="s1">PermissionError):</span>
            <span class="s2">pass</span>

        <span class="s0"># warn or raise exception if test failed</span>
        <span class="s2">if not </span><span class="s1">has_git:</span>
            <span class="s1">err = (</span>
                <span class="s1">dedent(</span>
                    <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
                </span><span class="s3">Bad git executable. 
                The git executable must be specified in one of the following ways: 
                    - be included in your $PATH 
                    - be set via $%s 
                    - explicitly set via git.refresh() 
                &quot;&quot;&quot;</span>
                <span class="s1">)</span>
                <span class="s1">% cls._git_exec_env_var</span>
            <span class="s1">)</span>

            <span class="s0"># revert to whatever the old_git was</span>
            <span class="s1">cls.GIT_PYTHON_GIT_EXECUTABLE = old_git</span>

            <span class="s2">if </span><span class="s1">old_git </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s0"># on the first refresh (when GIT_PYTHON_GIT_EXECUTABLE is</span>
                <span class="s0"># None) we only are quiet, warn, or error depending on the</span>
                <span class="s0"># GIT_PYTHON_REFRESH value</span>

                <span class="s0"># determine what the user wants to happen during the initial</span>
                <span class="s0"># refresh we expect GIT_PYTHON_REFRESH to either be unset or</span>
                <span class="s0"># be one of the following values:</span>
                <span class="s0">#   0|q|quiet|s|silence</span>
                <span class="s0">#   1|w|warn|warning</span>
                <span class="s0">#   2|r|raise|e|error</span>

                <span class="s1">mode = os.environ.get(cls._refresh_env_var</span><span class="s2">, </span><span class="s3">&quot;raise&quot;</span><span class="s1">).lower()</span>

                <span class="s1">quiet = [</span><span class="s3">&quot;quiet&quot;</span><span class="s2">, </span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s3">&quot;silence&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;none&quot;</span><span class="s2">, </span><span class="s3">&quot;n&quot;</span><span class="s2">, </span><span class="s3">&quot;0&quot;</span><span class="s1">]</span>
                <span class="s1">warn = [</span><span class="s3">&quot;warn&quot;</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s2">, </span><span class="s3">&quot;warning&quot;</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span>
                <span class="s1">error = [</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s2">, </span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;r&quot;</span><span class="s2">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span>

                <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">quiet:</span>
                    <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">warn </span><span class="s2">or </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">error:</span>
                    <span class="s1">err = (</span>
                        <span class="s1">dedent(</span>
                            <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
                        </span><span class="s3">%s 
                        All git commands will error until this is rectified. 
 
                        This initial warning can be silenced or aggravated in the future by setting the 
                        $%s environment variable. Use one of the following values: 
                            - %s: for no warning or exception 
                            - %s: for a printed warning 
                            - %s: for a raised exception 
 
                        Example: 
                            export %s=%s 
                        &quot;&quot;&quot;</span>
                        <span class="s1">)</span>
                        <span class="s1">% (</span>
                            <span class="s1">err</span><span class="s2">,</span>
                            <span class="s1">cls._refresh_env_var</span><span class="s2">,</span>
                            <span class="s3">&quot;|&quot;</span><span class="s1">.join(quiet)</span><span class="s2">,</span>
                            <span class="s3">&quot;|&quot;</span><span class="s1">.join(warn)</span><span class="s2">,</span>
                            <span class="s3">&quot;|&quot;</span><span class="s1">.join(error)</span><span class="s2">,</span>
                            <span class="s1">cls._refresh_env_var</span><span class="s2">,</span>
                            <span class="s1">quiet[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                    <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">warn:</span>
                        <span class="s1">print(</span><span class="s3">&quot;WARNING: %s&quot; </span><span class="s1">% err)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">ImportError(err)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">err = (</span>
                        <span class="s1">dedent(</span>
                            <span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
                        </span><span class="s3">%s environment variable has been set but it has been set with an invalid value. 
 
                        Use only the following values: 
                            - %s: for no warning or exception 
                            - %s: for a printed warning 
                            - %s: for a raised exception 
                        &quot;&quot;&quot;</span>
                        <span class="s1">)</span>
                        <span class="s1">% (</span>
                            <span class="s1">cls._refresh_env_var</span><span class="s2">,</span>
                            <span class="s3">&quot;|&quot;</span><span class="s1">.join(quiet)</span><span class="s2">,</span>
                            <span class="s3">&quot;|&quot;</span><span class="s1">.join(warn)</span><span class="s2">,</span>
                            <span class="s3">&quot;|&quot;</span><span class="s1">.join(error)</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s2">raise </span><span class="s1">ImportError(err)</span>

                <span class="s0"># we get here if this was the init refresh and the refresh mode</span>
                <span class="s0"># was not error, go ahead and set the GIT_PYTHON_GIT_EXECUTABLE</span>
                <span class="s0"># such that we discern the difference between a first import</span>
                <span class="s0"># and a second import</span>
                <span class="s1">cls.GIT_PYTHON_GIT_EXECUTABLE = cls.git_exec_name</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># after the first refresh (when GIT_PYTHON_GIT_EXECUTABLE</span>
                <span class="s0"># is no longer None) we raise an exception</span>
                <span class="s2">raise </span><span class="s1">GitCommandNotFound(</span><span class="s3">&quot;git&quot;</span><span class="s2">, </span><span class="s1">err)</span>

        <span class="s2">return </span><span class="s1">has_git</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_cygwin(cls) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">is_cygwin_git(cls.GIT_PYTHON_GIT_EXECUTABLE)</span>

    <span class="s1">@overload</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">polish_url(cls</span><span class="s2">, </span><span class="s1">url: str</span><span class="s2">, </span><span class="s1">is_cygwin: Literal[</span><span class="s2">False</span><span class="s1">] = ...) -&gt; str:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">polish_url(cls</span><span class="s2">, </span><span class="s1">url: str</span><span class="s2">, </span><span class="s1">is_cygwin: Union[</span><span class="s2">None, </span><span class="s1">bool] = </span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s1">...</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">polish_url(cls</span><span class="s2">, </span><span class="s1">url: str</span><span class="s2">, </span><span class="s1">is_cygwin: Union[</span><span class="s2">None, </span><span class="s1">bool] = </span><span class="s2">None</span><span class="s1">) -&gt; PathLike:</span>
        <span class="s2">if </span><span class="s1">is_cygwin </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">is_cygwin = cls.is_cygwin()</span>

        <span class="s2">if </span><span class="s1">is_cygwin:</span>
            <span class="s1">url = cygpath(url)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3">&quot;&quot;&quot;Remove any backslahes from urls to be written in config files. 
 
            Windows might create config-files containing paths with backslashed, 
            but git stops liking them as it will escape the backslashes. 
            Hence we undo the escaping just to be sure. 
            &quot;&quot;&quot;</span>
            <span class="s1">url = os.path.expandvars(url)</span>
            <span class="s2">if </span><span class="s1">url.startswith(</span><span class="s3">&quot;~&quot;</span><span class="s1">):</span>
                <span class="s1">url = os.path.expanduser(url)</span>
            <span class="s1">url = url.replace(</span><span class="s3">&quot;</span><span class="s2">\\\\</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">url</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">check_unsafe_protocols(cls</span><span class="s2">, </span><span class="s1">url: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Check for unsafe protocols. 
 
        Apart from the usual protocols (http, git, ssh), 
        Git allows &quot;remote helpers&quot; that have the form `&lt;transport&gt;::&lt;address&gt;`, 
        one of these helpers (`ext::`) can be used to invoke any arbitrary command. 
 
        See: 
 
        - https://git-scm.com/docs/gitremote-helpers 
        - https://git-scm.com/docs/git-remote-ext 
        &quot;&quot;&quot;</span>
        <span class="s1">match = cls.re_unsafe_protocol.match(url)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">protocol = match.group(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">UnsafeProtocolError(</span>
                <span class="s3">f&quot;The `</span><span class="s2">{</span><span class="s1">protocol</span><span class="s2">}</span><span class="s3">::` protocol looks suspicious, use `allow_unsafe_protocols=True` to allow it.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">check_unsafe_options(cls</span><span class="s2">, </span><span class="s1">options: List[str]</span><span class="s2">, </span><span class="s1">unsafe_options: List[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Check for unsafe options. 
 
        Some options that are passed to `git &lt;command&gt;` can be used to execute 
        arbitrary commands, this are blocked by default. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Options can be of the form `foo` or `--foo bar` `--foo=bar`,</span>
        <span class="s0"># so we need to check if they start with &quot;--foo&quot; or if they are equal to &quot;foo&quot;.</span>
        <span class="s1">bare_unsafe_options = [</span>
            <span class="s1">option.lstrip(</span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">unsafe_options</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">options:</span>
            <span class="s2">for </span><span class="s1">unsafe_option</span><span class="s2">, </span><span class="s1">bare_option </span><span class="s2">in </span><span class="s1">zip(unsafe_options</span><span class="s2">, </span><span class="s1">bare_unsafe_options):</span>
                <span class="s2">if </span><span class="s1">option.startswith(unsafe_option) </span><span class="s2">or </span><span class="s1">option == bare_option:</span>
                    <span class="s2">raise </span><span class="s1">UnsafeOptionError(</span>
                        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">unsafe_option</span><span class="s2">} </span><span class="s3">is not allowed, use `allow_unsafe_options=True` to allow it.&quot;</span>
                    <span class="s1">)</span>

    <span class="s2">class </span><span class="s1">AutoInterrupt(object):</span>
        <span class="s4">&quot;&quot;&quot;Kill/Interrupt the stored process instance once this instance goes out of scope. It is 
        used to prevent processes piling up in case iterators stop reading. 
        Besides all attributes are wired through to the contained process object. 
 
        The wait method was overridden to perform automatic status code checking 
        and possibly raise.&quot;&quot;&quot;</span>

        <span class="s1">__slots__ = (</span><span class="s3">&quot;proc&quot;</span><span class="s2">, </span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s3">&quot;status&quot;</span><span class="s1">)</span>

        <span class="s0"># If this is non-zero it will override any status code during</span>
        <span class="s0"># _terminate, used to prevent race conditions in testing</span>
        <span class="s1">_status_code_if_terminate: int = </span><span class="s5">0</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">proc: Union[</span><span class="s2">None, </span><span class="s1">subprocess.Popen]</span><span class="s2">, </span><span class="s1">args: Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">self.proc = proc</span>
            <span class="s1">self.args = args</span>
            <span class="s1">self.status: Union[int</span><span class="s2">, None</span><span class="s1">] = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">_terminate(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s4">&quot;&quot;&quot;Terminate the underlying process&quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">self.proc </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return</span>

            <span class="s1">proc = self.proc</span>
            <span class="s1">self.proc = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">proc.stdin:</span>
                <span class="s1">proc.stdin.close()</span>
            <span class="s2">if </span><span class="s1">proc.stdout:</span>
                <span class="s1">proc.stdout.close()</span>
            <span class="s2">if </span><span class="s1">proc.stderr:</span>
                <span class="s1">proc.stderr.close()</span>
            <span class="s0"># did the process finish already so we have a return code ?</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">proc.poll() </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.status = self._status_code_if_terminate </span><span class="s2">or </span><span class="s1">proc.poll()</span>
                    <span class="s2">return None</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">ex:</span>
                <span class="s1">log.info(</span><span class="s3">&quot;Ignored error after process had died: %r&quot;</span><span class="s2">, </span><span class="s1">ex)</span>

            <span class="s0"># can be that nothing really exists anymore ...</span>
            <span class="s2">if </span><span class="s1">os </span><span class="s2">is None or </span><span class="s1">getattr(os</span><span class="s2">, </span><span class="s3">&quot;kill&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>

            <span class="s0"># try to kill it</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">proc.terminate()</span>
                <span class="s1">status = proc.wait()  </span><span class="s0"># ensure process goes away</span>

                <span class="s1">self.status = self._status_code_if_terminate </span><span class="s2">or </span><span class="s1">status</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">ex:</span>
                <span class="s1">log.info(</span><span class="s3">&quot;Ignored error after process had died: %r&quot;</span><span class="s2">, </span><span class="s1">ex)</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s0"># try windows</span>
                <span class="s0"># for some reason, providing None for stdout/stderr still prints something. This is why</span>
                <span class="s0"># we simply use the shell and redirect to nul. Its slower than CreateProcess, question</span>
                <span class="s0"># is whether we really want to see all these messages. Its annoying no matter what.</span>
                <span class="s2">if </span><span class="s1">is_win:</span>
                    <span class="s1">call(</span>
                        <span class="s1">(</span><span class="s3">&quot;TASKKILL /F /T /PID %s 2&gt;nul 1&gt;nul&quot; </span><span class="s1">% str(proc.pid))</span><span class="s2">,</span>
                        <span class="s1">shell=</span><span class="s2">True,</span>
                    <span class="s1">)</span>
            <span class="s0"># END exception handling</span>

        <span class="s2">def </span><span class="s1">__del__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">self._terminate()</span>

        <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr: str) -&gt; Any:</span>
            <span class="s2">return </span><span class="s1">getattr(self.proc</span><span class="s2">, </span><span class="s1">attr)</span>

        <span class="s0"># TODO: Bad choice to mimic `proc.wait()` but with different args.</span>
        <span class="s2">def </span><span class="s1">wait(self</span><span class="s2">, </span><span class="s1">stderr: Union[</span><span class="s2">None, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes] = </span><span class="s6">b&quot;&quot;</span><span class="s1">) -&gt; int:</span>
            <span class="s4">&quot;&quot;&quot;Wait for the process and return its status code. 
 
            :param stderr: Previously read value of stderr, in case stderr is already closed. 
            :warn: may deadlock if output or error pipes are used and not handled separately. 
            :raise GitCommandError: if the return status is not 0&quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">stderr </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">stderr_b = </span><span class="s6">b&quot;&quot;</span>
            <span class="s1">stderr_b = force_bytes(data=stderr</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
            <span class="s1">status: Union[int</span><span class="s2">, None</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self.proc </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">status = self.proc.wait()</span>
                <span class="s1">p_stderr = self.proc.stderr</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s0"># Assume the underlying proc was killed earlier or never existed</span>
                <span class="s1">status = self.status</span>
                <span class="s1">p_stderr = </span><span class="s2">None</span>

            <span class="s2">def </span><span class="s1">read_all_from_possibly_closed_stream(stream: Union[IO[bytes]</span><span class="s2">, None</span><span class="s1">]) -&gt; bytes:</span>
                <span class="s2">if </span><span class="s1">stream:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">stderr_b + force_bytes(stream.read())</span>
                    <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                        <span class="s2">return </span><span class="s1">stderr_b </span><span class="s2">or </span><span class="s6">b&quot;&quot;</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">stderr_b </span><span class="s2">or </span><span class="s6">b&quot;&quot;</span>

            <span class="s0"># END status handling</span>

            <span class="s2">if </span><span class="s1">status != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">errstr = read_all_from_possibly_closed_stream(p_stderr)</span>
                <span class="s1">log.debug(</span><span class="s3">&quot;AutoInterrupt wait stderr: %r&quot; </span><span class="s1">% (errstr</span><span class="s2">,</span><span class="s1">))</span>
                <span class="s2">raise </span><span class="s1">GitCommandError(remove_password_if_present(self.args)</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">errstr)</span>
            <span class="s2">return </span><span class="s1">status</span>

    <span class="s0"># END auto interrupt</span>

    <span class="s2">class </span><span class="s1">CatFileContentStream(object):</span>

        <span class="s4">&quot;&quot;&quot;Object representing a sized read-only stream returning the contents of 
        an object. 
        It behaves like a stream, but counts the data read and simulates an empty 
        stream once our sized content region is empty. 
        If not all data is read to the end of the objects's lifetime, we read the 
        rest to assure the underlying stream continues to work&quot;&quot;&quot;</span>

        <span class="s1">__slots__: Tuple[str</span><span class="s2">, </span><span class="s1">...] = (</span><span class="s3">&quot;_stream&quot;</span><span class="s2">, </span><span class="s3">&quot;_nbr&quot;</span><span class="s2">, </span><span class="s3">&quot;_size&quot;</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">size: int</span><span class="s2">, </span><span class="s1">stream: IO[bytes]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">self._stream = stream</span>
            <span class="s1">self._size = size</span>
            <span class="s1">self._nbr = </span><span class="s5">0  </span><span class="s0"># num bytes read</span>

            <span class="s0"># special case: if the object is empty, has null bytes, get the</span>
            <span class="s0"># final newline right away.</span>
            <span class="s2">if </span><span class="s1">size == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">stream.read(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s0"># END handle empty streams</span>

        <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size: int = -</span><span class="s5">1</span><span class="s1">) -&gt; bytes:</span>
            <span class="s1">bytes_left = self._size - self._nbr</span>
            <span class="s2">if </span><span class="s1">bytes_left == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s6">b&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">size &gt; -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0"># assure we don't try to read past our limit</span>
                <span class="s1">size = min(bytes_left</span><span class="s2">, </span><span class="s1">size)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># they try to read all, make sure its not more than what remains</span>
                <span class="s1">size = bytes_left</span>
            <span class="s0"># END check early depletion</span>
            <span class="s1">data = self._stream.read(size)</span>
            <span class="s1">self._nbr += len(data)</span>

            <span class="s0"># check for depletion, read our final byte to make the stream usable by others</span>
            <span class="s2">if </span><span class="s1">self._size - self._nbr == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self._stream.read(</span><span class="s5">1</span><span class="s1">)  </span><span class="s0"># final newline</span>
            <span class="s0"># END finish reading</span>
            <span class="s2">return </span><span class="s1">data</span>

        <span class="s2">def </span><span class="s1">readline(self</span><span class="s2">, </span><span class="s1">size: int = -</span><span class="s5">1</span><span class="s1">) -&gt; bytes:</span>
            <span class="s2">if </span><span class="s1">self._nbr == self._size:</span>
                <span class="s2">return </span><span class="s6">b&quot;&quot;</span>

            <span class="s0"># clamp size to lowest allowed value</span>
            <span class="s1">bytes_left = self._size - self._nbr</span>
            <span class="s2">if </span><span class="s1">size &gt; -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">size = min(bytes_left</span><span class="s2">, </span><span class="s1">size)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">size = bytes_left</span>
            <span class="s0"># END handle size</span>

            <span class="s1">data = self._stream.readline(size)</span>
            <span class="s1">self._nbr += len(data)</span>

            <span class="s0"># handle final byte</span>
            <span class="s2">if </span><span class="s1">self._size - self._nbr == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self._stream.read(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s0"># END finish reading</span>

            <span class="s2">return </span><span class="s1">data</span>

        <span class="s2">def </span><span class="s1">readlines(self</span><span class="s2">, </span><span class="s1">size: int = -</span><span class="s5">1</span><span class="s1">) -&gt; List[bytes]:</span>
            <span class="s2">if </span><span class="s1">self._nbr == self._size:</span>
                <span class="s2">return </span><span class="s1">[]</span>

            <span class="s0"># leave all additional logic to our readline method, we just check the size</span>
            <span class="s1">out = []</span>
            <span class="s1">nbr = </span><span class="s5">0</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">line = self.readline()</span>
                <span class="s2">if not </span><span class="s1">line:</span>
                    <span class="s2">break</span>
                <span class="s1">out.append(line)</span>
                <span class="s2">if </span><span class="s1">size &gt; -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">nbr += len(line)</span>
                    <span class="s2">if </span><span class="s1">nbr &gt; size:</span>
                        <span class="s2">break</span>
                <span class="s0"># END handle size constraint</span>
            <span class="s0"># END readline loop</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s0"># skipcq: PYL-E0301</span>
        <span class="s2">def </span><span class="s1">__iter__(self) -&gt; </span><span class="s3">&quot;Git.CatFileContentStream&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">def </span><span class="s1">__next__(self) -&gt; bytes:</span>
            <span class="s1">line = self.readline()</span>
            <span class="s2">if not </span><span class="s1">line:</span>
                <span class="s2">raise </span><span class="s1">StopIteration</span>

            <span class="s2">return </span><span class="s1">line</span>

        <span class="s1">next = __next__</span>

        <span class="s2">def </span><span class="s1">__del__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">bytes_left = self._size - self._nbr</span>
            <span class="s2">if </span><span class="s1">bytes_left:</span>
                <span class="s0"># read and discard - seeking is impossible within a stream</span>
                <span class="s0"># includes terminating newline</span>
                <span class="s1">self._stream.read(bytes_left + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s0"># END handle incomplete read</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">working_dir: Union[</span><span class="s2">None, </span><span class="s1">PathLike] = </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Initialize this instance with: 
 
        :param working_dir: 
           Git directory we should work in. If None, we always work in the current 
           directory as returned by os.getcwd(). 
           It is meant to be the working tree directory if available, or the 
           .git directory in case of bare repositories.&quot;&quot;&quot;</span>
        <span class="s1">super(Git</span><span class="s2">, </span><span class="s1">self).__init__()</span>
        <span class="s1">self._working_dir = expand_path(working_dir)</span>
        <span class="s1">self._git_options: Union[List[str]</span><span class="s2">, </span><span class="s1">Tuple[str</span><span class="s2">, </span><span class="s1">...]] = ()</span>
        <span class="s1">self._persistent_git_options: List[str] = []</span>

        <span class="s0"># Extra environment variables to pass to git commands</span>
        <span class="s1">self._environment: Dict[str</span><span class="s2">, </span><span class="s1">str] = {}</span>

        <span class="s0"># cached command slots</span>
        <span class="s1">self.cat_file_header: Union[</span><span class="s2">None, </span><span class="s1">TBD] = </span><span class="s2">None</span>
        <span class="s1">self.cat_file_all: Union[</span><span class="s2">None, </span><span class="s1">TBD] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; Any:</span>
        <span class="s4">&quot;&quot;&quot;A convenience method as it allows to call the command as if it was 
        an object. 
 
        :return: Callable object that will execute call _call_process with your arguments.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;_&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">LazyMixin.__getattr__(self</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">return lambda </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs: self._call_process(name</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">set_persistent_git_options(self</span><span class="s2">, </span><span class="s1">**kwargs: Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Specify command line options to the git executable 
        for subsequent subcommand calls 
 
        :param kwargs: 
            is a dict of keyword arguments. 
            these arguments are passed as in _call_process 
            but will be passed to the git command rather than 
            the subcommand. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._persistent_git_options = self.transform_kwargs(split_single_char_options=</span><span class="s2">True, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_set_cache_(self</span><span class="s2">, </span><span class="s1">attr: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">attr == </span><span class="s3">&quot;_version_info&quot;</span><span class="s1">:</span>
            <span class="s0"># We only use the first 4 numbers, as everything else could be strings in fact (on windows)</span>
            <span class="s1">process_version = self._call_process(</span><span class="s3">&quot;version&quot;</span><span class="s1">)  </span><span class="s0"># should be as default *args and **kwargs used</span>
            <span class="s1">version_numbers = process_version.split(</span><span class="s3">&quot; &quot;</span><span class="s1">)[</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s1">self._version_info = cast(</span>
                <span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]</span><span class="s2">,</span>
                <span class="s1">tuple(int(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">version_numbers.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)[:</span><span class="s5">4</span><span class="s1">] </span><span class="s2">if </span><span class="s1">n.isdigit())</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">super(Git</span><span class="s2">, </span><span class="s1">self)._set_cache_(attr)</span>
        <span class="s0"># END handle version info</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">working_dir(self) -&gt; Union[</span><span class="s2">None, </span><span class="s1">PathLike]:</span>
        <span class="s4">&quot;&quot;&quot;:return: Git directory we are working on&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._working_dir</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">version_info(self) -&gt; Tuple[int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s4">&quot;&quot;&quot; 
        :return: tuple(int, int, int, int) tuple with integers representing the major, minor 
            and additional version numbers as parsed from git version. 
            This value is generated on demand and is cached&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._version_info</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">execute(self</span><span class="s2">, </span><span class="s1">command: Union[str</span><span class="s2">, </span><span class="s1">Sequence[Any]]</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">as_process: Literal[</span><span class="s2">True</span><span class="s1">]) -&gt; </span><span class="s3">&quot;AutoInterrupt&quot;</span><span class="s1">:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">execute(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">command: Union[str</span><span class="s2">, </span><span class="s1">Sequence[Any]]</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">as_process: Literal[</span><span class="s2">False</span><span class="s1">] = </span><span class="s2">False,</span>
        <span class="s1">stdout_as_string: Literal[</span><span class="s2">True</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">) -&gt; Union[str</span><span class="s2">, </span><span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">execute(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">command: Union[str</span><span class="s2">, </span><span class="s1">Sequence[Any]]</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">as_process: Literal[</span><span class="s2">False</span><span class="s1">] = </span><span class="s2">False,</span>
        <span class="s1">stdout_as_string: Literal[</span><span class="s2">False</span><span class="s1">] = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; Union[bytes</span><span class="s2">, </span><span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">execute(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">command: Union[str</span><span class="s2">, </span><span class="s1">Sequence[Any]]</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">with_extended_output: Literal[</span><span class="s2">False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">as_process: Literal[</span><span class="s2">False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">stdout_as_string: Literal[</span><span class="s2">True</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">execute(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">command: Union[str</span><span class="s2">, </span><span class="s1">Sequence[Any]]</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">with_extended_output: Literal[</span><span class="s2">False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">as_process: Literal[</span><span class="s2">False</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">stdout_as_string: Literal[</span><span class="s2">False</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">) -&gt; bytes:</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">execute(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">command: Union[str</span><span class="s2">, </span><span class="s1">Sequence[Any]]</span><span class="s2">,</span>
        <span class="s1">istream: Union[</span><span class="s2">None, </span><span class="s1">BinaryIO] = </span><span class="s2">None,</span>
        <span class="s1">with_extended_output: bool = </span><span class="s2">False,</span>
        <span class="s1">with_exceptions: bool = </span><span class="s2">True,</span>
        <span class="s1">as_process: bool = </span><span class="s2">False,</span>
        <span class="s1">output_stream: Union[</span><span class="s2">None, </span><span class="s1">BinaryIO] = </span><span class="s2">None,</span>
        <span class="s1">stdout_as_string: bool = </span><span class="s2">True,</span>
        <span class="s1">kill_after_timeout: Union[</span><span class="s2">None, </span><span class="s1">float] = </span><span class="s2">None,</span>
        <span class="s1">with_stdout: bool = </span><span class="s2">True,</span>
        <span class="s1">universal_newlines: bool = </span><span class="s2">False,</span>
        <span class="s1">shell: Union[</span><span class="s2">None, </span><span class="s1">bool] = </span><span class="s2">None,</span>
        <span class="s1">env: Union[</span><span class="s2">None, </span><span class="s1">Mapping[str</span><span class="s2">, </span><span class="s1">str]] = </span><span class="s2">None,</span>
        <span class="s1">max_chunk_size: int = io.DEFAULT_BUFFER_SIZE</span><span class="s2">,</span>
        <span class="s1">strip_newline_in_stdout: bool = </span><span class="s2">True,</span>
        <span class="s1">**subprocess_kwargs: Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">Union[str</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">AutoInterrupt]:</span>
        <span class="s4">&quot;&quot;&quot;Handles executing the command on the shell and consumes and returns 
        the returned information (stdout) 
 
        :param command: 
            The command argument list to execute. 
            It should be a string, or a sequence of program arguments. The 
            program to execute is the first item in the args sequence or string. 
 
        :param istream: 
            Standard input filehandle passed to subprocess.Popen. 
 
        :param with_extended_output: 
            Whether to return a (status, stdout, stderr) tuple. 
 
        :param with_exceptions: 
            Whether to raise an exception when git returns a non-zero status. 
 
        :param as_process: 
            Whether to return the created process instance directly from which 
            streams can be read on demand. This will render with_extended_output and 
            with_exceptions ineffective - the caller will have 
            to deal with the details himself. 
            It is important to note that the process will be placed into an AutoInterrupt 
            wrapper that will interrupt the process once it goes out of scope. If you 
            use the command in iterators, you should pass the whole process instance 
            instead of a single stream. 
 
        :param output_stream: 
            If set to a file-like object, data produced by the git command will be 
            output to the given stream directly. 
            This feature only has any effect if as_process is False. Processes will 
            always be created with a pipe due to issues with subprocess. 
            This merely is a workaround as data will be copied from the 
            output pipe to the given output stream directly. 
            Judging from the implementation, you shouldn't use this flag ! 
 
        :param stdout_as_string: 
            if False, the commands standard output will be bytes. Otherwise, it will be 
            decoded into a string using the default encoding (usually utf-8). 
            The latter can fail, if the output contains binary data. 
 
        :param env: 
            A dictionary of environment variables to be passed to `subprocess.Popen`. 
 
        :param max_chunk_size: 
            Maximum number of bytes in one chunk of data passed to the output_stream in 
            one invocation of write() method. If the given number is not positive then 
            the default value is used. 
 
        :param subprocess_kwargs: 
            Keyword arguments to be passed to subprocess.Popen. Please note that 
            some of the valid kwargs are already set by this method, the ones you 
            specify may not be the same ones. 
 
        :param with_stdout: If True, default True, we open stdout on the created process 
        :param universal_newlines: 
            if True, pipes will be opened as text, and lines are split at 
            all known line endings. 
        :param shell: 
            Whether to invoke commands through a shell (see `Popen(..., shell=True)`). 
            It overrides :attr:`USE_SHELL` if it is not `None`. 
        :param kill_after_timeout: 
            To specify a timeout in seconds for the git command, after which the process 
            should be killed. This will have no effect if as_process is set to True. It is 
            set to None by default and will let the process run until the timeout is 
            explicitly specified. This feature is not supported on Windows. It's also worth 
            noting that kill_after_timeout uses SIGKILL, which can have negative side 
            effects on a repository. For example, stale locks in case of git gc could 
            render the repository incapable of accepting changes until the lock is manually 
            removed. 
        :param strip_newline_in_stdout: 
            Whether to strip the trailing ``\\n`` of the command stdout. 
        :return: 
            * str(output) if extended_output = False (Default) 
            * tuple(int(status), str(stdout), str(stderr)) if extended_output = True 
 
            if output_stream is True, the stdout value will be your output stream: 
            * output_stream if extended_output = False 
            * tuple(int(status), output_stream, str(stderr)) if extended_output = True 
 
            Note git is executed with LC_MESSAGES=&quot;C&quot; to ensure consistent 
            output regardless of system language. 
 
        :raise GitCommandError: 
 
        :note: 
           If you add additional keyword arguments to the signature of this method, 
           you must update the execute_kwargs tuple housed in this module.&quot;&quot;&quot;</span>
        <span class="s0"># Remove password for the command if present</span>
        <span class="s1">redacted_command = remove_password_if_present(command)</span>
        <span class="s2">if </span><span class="s1">self.GIT_PYTHON_TRACE </span><span class="s2">and </span><span class="s1">(self.GIT_PYTHON_TRACE != </span><span class="s3">&quot;full&quot; </span><span class="s2">or </span><span class="s1">as_process):</span>
            <span class="s1">log.info(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(redacted_command))</span>

        <span class="s0"># Allow the user to have the command executed in their working dir.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">cwd = self._working_dir </span><span class="s2">or </span><span class="s1">os.getcwd()  </span><span class="s0"># type: Union[None, str]</span>
            <span class="s2">if not </span><span class="s1">os.access(str(cwd)</span><span class="s2">, </span><span class="s1">os.X_OK):</span>
                <span class="s1">cwd = </span><span class="s2">None</span>
        <span class="s2">except </span><span class="s1">FileNotFoundError:</span>
            <span class="s1">cwd = </span><span class="s2">None</span>

        <span class="s0"># Start the process</span>
        <span class="s1">inline_env = env</span>
        <span class="s1">env = os.environ.copy()</span>
        <span class="s0"># Attempt to force all output to plain ascii english, which is what some parsing code</span>
        <span class="s0"># may expect.</span>
        <span class="s0"># According to stackoverflow (http://goo.gl/l74GC8), we are setting LANGUAGE as well</span>
        <span class="s0"># just to be sure.</span>
        <span class="s1">env[</span><span class="s3">&quot;LANGUAGE&quot;</span><span class="s1">] = </span><span class="s3">&quot;C&quot;</span>
        <span class="s1">env[</span><span class="s3">&quot;LC_ALL&quot;</span><span class="s1">] = </span><span class="s3">&quot;C&quot;</span>
        <span class="s1">env.update(self._environment)</span>
        <span class="s2">if </span><span class="s1">inline_env </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">env.update(inline_env)</span>

        <span class="s2">if </span><span class="s1">is_win:</span>
            <span class="s1">cmd_not_found_exception = OSError</span>
            <span class="s2">if </span><span class="s1">kill_after_timeout </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">GitCommandError(</span>
                    <span class="s1">redacted_command</span><span class="s2">,</span>
                    <span class="s3">'&quot;kill_after_timeout&quot; feature is not supported on Windows.'</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cmd_not_found_exception = FileNotFoundError  </span><span class="s0"># NOQA # exists, flake8 unknown @UndefinedVariable</span>
        <span class="s0"># end handle</span>

        <span class="s1">stdout_sink = PIPE </span><span class="s2">if </span><span class="s1">with_stdout </span><span class="s2">else </span><span class="s1">getattr(subprocess</span><span class="s2">, </span><span class="s3">&quot;DEVNULL&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">open(os.devnull</span><span class="s2">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
        <span class="s1">istream_ok = </span><span class="s3">&quot;None&quot;</span>
        <span class="s2">if </span><span class="s1">istream:</span>
            <span class="s1">istream_ok = </span><span class="s3">&quot;&lt;valid stream&gt;&quot;</span>
        <span class="s1">log.debug(</span>
            <span class="s3">&quot;Popen(%s, cwd=%s, universal_newlines=%s, shell=%s, istream=%s)&quot;</span><span class="s2">,</span>
            <span class="s1">redacted_command</span><span class="s2">,</span>
            <span class="s1">cwd</span><span class="s2">,</span>
            <span class="s1">universal_newlines</span><span class="s2">,</span>
            <span class="s1">shell</span><span class="s2">,</span>
            <span class="s1">istream_ok</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">proc = Popen(</span>
                <span class="s1">command</span><span class="s2">,</span>
                <span class="s1">env=env</span><span class="s2">,</span>
                <span class="s1">cwd=cwd</span><span class="s2">,</span>
                <span class="s1">bufsize=-</span><span class="s5">1</span><span class="s2">,</span>
                <span class="s1">stdin=istream </span><span class="s2">or </span><span class="s1">DEVNULL</span><span class="s2">,</span>
                <span class="s1">stderr=PIPE</span><span class="s2">,</span>
                <span class="s1">stdout=stdout_sink</span><span class="s2">,</span>
                <span class="s1">shell=shell </span><span class="s2">is not None and </span><span class="s1">shell </span><span class="s2">or </span><span class="s1">self.USE_SHELL</span><span class="s2">,</span>
                <span class="s1">close_fds=is_posix</span><span class="s2">,  </span><span class="s0"># unsupported on windows</span>
                <span class="s1">universal_newlines=universal_newlines</span><span class="s2">,</span>
                <span class="s1">creationflags=PROC_CREATIONFLAGS</span><span class="s2">,</span>
                <span class="s1">**subprocess_kwargs</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">except </span><span class="s1">cmd_not_found_exception </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">GitCommandNotFound(redacted_command</span><span class="s2">, </span><span class="s1">err) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># replace with a typeguard for Popen[bytes]?</span>
            <span class="s1">proc.stdout = cast(BinaryIO</span><span class="s2">, </span><span class="s1">proc.stdout)</span>
            <span class="s1">proc.stderr = cast(BinaryIO</span><span class="s2">, </span><span class="s1">proc.stderr)</span>

        <span class="s2">if </span><span class="s1">as_process:</span>
            <span class="s2">return </span><span class="s1">self.AutoInterrupt(proc</span><span class="s2">, </span><span class="s1">command)</span>

        <span class="s2">def </span><span class="s1">_kill_process(pid: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s4">&quot;&quot;&quot;Callback method to kill a process.&quot;&quot;&quot;</span>
            <span class="s1">p = Popen(</span>
                <span class="s1">[</span><span class="s3">&quot;ps&quot;</span><span class="s2">, </span><span class="s3">&quot;--ppid&quot;</span><span class="s2">, </span><span class="s1">str(pid)]</span><span class="s2">,</span>
                <span class="s1">stdout=PIPE</span><span class="s2">,</span>
                <span class="s1">creationflags=PROC_CREATIONFLAGS</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">child_pids = []</span>
            <span class="s2">if </span><span class="s1">p.stdout </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">p.stdout:</span>
                    <span class="s2">if </span><span class="s1">len(line.split()) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">local_pid = (line.split())[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s2">if </span><span class="s1">local_pid.isdigit():</span>
                            <span class="s1">child_pids.append(int(local_pid))</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># Windows does not have SIGKILL, so use SIGTERM instead</span>
                <span class="s1">sig = getattr(signal</span><span class="s2">, </span><span class="s3">&quot;SIGKILL&quot;</span><span class="s2">, </span><span class="s1">signal.SIGTERM)</span>
                <span class="s1">os.kill(pid</span><span class="s2">, </span><span class="s1">sig)</span>
                <span class="s2">for </span><span class="s1">child_pid </span><span class="s2">in </span><span class="s1">child_pids:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">os.kill(child_pid</span><span class="s2">, </span><span class="s1">sig)</span>
                    <span class="s2">except </span><span class="s1">OSError:</span>
                        <span class="s2">pass</span>
                <span class="s1">kill_check.set()  </span><span class="s0"># tell the main routine that the process was killed</span>
            <span class="s2">except </span><span class="s1">OSError:</span>
                <span class="s0"># It is possible that the process gets completed in the duration after timeout</span>
                <span class="s0"># happens and before we try to kill the process.</span>
                <span class="s2">pass</span>
            <span class="s2">return</span>

        <span class="s0"># end</span>

        <span class="s2">if </span><span class="s1">kill_after_timeout </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kill_check = threading.Event()</span>
            <span class="s1">watchdog = threading.Timer(kill_after_timeout</span><span class="s2">, </span><span class="s1">_kill_process</span><span class="s2">, </span><span class="s1">args=(proc.pid</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s0"># Wait for the process to return</span>
        <span class="s1">status = </span><span class="s5">0</span>
        <span class="s1">stdout_value: Union[str</span><span class="s2">, </span><span class="s1">bytes] = </span><span class="s6">b&quot;&quot;</span>
        <span class="s1">stderr_value: Union[str</span><span class="s2">, </span><span class="s1">bytes] = </span><span class="s6">b&quot;&quot;</span>
        <span class="s1">newline = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">universal_newlines </span><span class="s2">else </span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">output_stream </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">kill_after_timeout </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">watchdog.start()</span>
                <span class="s1">stdout_value</span><span class="s2">, </span><span class="s1">stderr_value = proc.communicate()</span>
                <span class="s2">if </span><span class="s1">kill_after_timeout </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">watchdog.cancel()</span>
                    <span class="s2">if </span><span class="s1">kill_check.is_set():</span>
                        <span class="s1">stderr_value = </span><span class="s3">'Timeout: the command &quot;%s&quot; did not complete in %d ' &quot;secs.&quot; </span><span class="s1">% (</span>
                            <span class="s3">&quot; &quot;</span><span class="s1">.join(redacted_command)</span><span class="s2">,</span>
                            <span class="s1">kill_after_timeout</span><span class="s2">,</span>
                        <span class="s1">)</span>
                        <span class="s2">if not </span><span class="s1">universal_newlines:</span>
                            <span class="s1">stderr_value = stderr_value.encode(defenc)</span>
                <span class="s0"># strip trailing &quot;\n&quot;</span>
                <span class="s2">if </span><span class="s1">stdout_value.endswith(newline) </span><span class="s2">and </span><span class="s1">strip_newline_in_stdout:  </span><span class="s0"># type: ignore</span>
                    <span class="s1">stdout_value = stdout_value[:-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">stderr_value.endswith(newline):  </span><span class="s0"># type: ignore</span>
                    <span class="s1">stderr_value = stderr_value[:-</span><span class="s5">1</span><span class="s1">]</span>

                <span class="s1">status = proc.returncode</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">max_chunk_size = max_chunk_size </span><span class="s2">if </span><span class="s1">max_chunk_size </span><span class="s2">and </span><span class="s1">max_chunk_size &gt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">io.DEFAULT_BUFFER_SIZE</span>
                <span class="s1">stream_copy(proc.stdout</span><span class="s2">, </span><span class="s1">output_stream</span><span class="s2">, </span><span class="s1">max_chunk_size)</span>
                <span class="s1">stdout_value = proc.stdout.read()</span>
                <span class="s1">stderr_value = proc.stderr.read()</span>
                <span class="s0"># strip trailing &quot;\n&quot;</span>
                <span class="s2">if </span><span class="s1">stderr_value.endswith(newline):  </span><span class="s0"># type: ignore</span>
                    <span class="s1">stderr_value = stderr_value[:-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">status = proc.wait()</span>
            <span class="s0"># END stdout handling</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">proc.stdout.close()</span>
            <span class="s1">proc.stderr.close()</span>

        <span class="s2">if </span><span class="s1">self.GIT_PYTHON_TRACE == </span><span class="s3">&quot;full&quot;</span><span class="s1">:</span>
            <span class="s1">cmdstr = </span><span class="s3">&quot; &quot;</span><span class="s1">.join(redacted_command)</span>

            <span class="s2">def </span><span class="s1">as_text(stdout_value: Union[bytes</span><span class="s2">, </span><span class="s1">str]) -&gt; str:</span>
                <span class="s2">return not </span><span class="s1">output_stream </span><span class="s2">and </span><span class="s1">safe_decode(stdout_value) </span><span class="s2">or </span><span class="s3">&quot;&lt;OUTPUT_STREAM&gt;&quot;</span>

            <span class="s0"># end</span>

            <span class="s2">if </span><span class="s1">stderr_value:</span>
                <span class="s1">log.info(</span>
                    <span class="s3">&quot;%s -&gt; %d; stdout: '%s'; stderr: '%s'&quot;</span><span class="s2">,</span>
                    <span class="s1">cmdstr</span><span class="s2">,</span>
                    <span class="s1">status</span><span class="s2">,</span>
                    <span class="s1">as_text(stdout_value)</span><span class="s2">,</span>
                    <span class="s1">safe_decode(stderr_value)</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">stdout_value:</span>
                <span class="s1">log.info(</span><span class="s3">&quot;%s -&gt; %d; stdout: '%s'&quot;</span><span class="s2">, </span><span class="s1">cmdstr</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">as_text(stdout_value))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">log.info(</span><span class="s3">&quot;%s -&gt; %d&quot;</span><span class="s2">, </span><span class="s1">cmdstr</span><span class="s2">, </span><span class="s1">status)</span>
        <span class="s0"># END handle debug printing</span>

        <span class="s2">if </span><span class="s1">with_exceptions </span><span class="s2">and </span><span class="s1">status != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">GitCommandError(redacted_command</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">stderr_value</span><span class="s2">, </span><span class="s1">stdout_value)</span>

        <span class="s2">if </span><span class="s1">isinstance(stdout_value</span><span class="s2">, </span><span class="s1">bytes) </span><span class="s2">and </span><span class="s1">stdout_as_string:  </span><span class="s0"># could also be output_stream</span>
            <span class="s1">stdout_value = safe_decode(stdout_value)</span>

        <span class="s0"># Allow access to the command's status code</span>
        <span class="s2">if </span><span class="s1">with_extended_output:</span>
            <span class="s2">return </span><span class="s1">(status</span><span class="s2">, </span><span class="s1">stdout_value</span><span class="s2">, </span><span class="s1">safe_decode(stderr_value))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">stdout_value</span>

    <span class="s2">def </span><span class="s1">environment(self) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s2">return </span><span class="s1">self._environment</span>

    <span class="s2">def </span><span class="s1">update_environment(self</span><span class="s2">, </span><span class="s1">**kwargs: Any) -&gt; Dict[str</span><span class="s2">, </span><span class="s1">Union[str</span><span class="s2">, None</span><span class="s1">]]:</span>
        <span class="s4">&quot;&quot;&quot; 
        Set environment variables for future git invocations. Return all changed 
        values in a format that can be passed back into this function to revert 
        the changes: 
 
        ``Examples``:: 
 
            old_env = self.update_environment(PWD='/tmp') 
            self.update_environment(**old_env) 
 
        :param kwargs: environment variables to use for git processes 
        :return: dict that maps environment variables to their old values 
        &quot;&quot;&quot;</span>
        <span class="s1">old_env = {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">kwargs.items():</span>
            <span class="s0"># set value if it is None</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">old_env[key] = self._environment.get(key)</span>
                <span class="s1">self._environment[key] = value</span>
            <span class="s0"># remove key from environment if its value is None</span>
            <span class="s2">elif </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self._environment:</span>
                <span class="s1">old_env[key] = self._environment[key]</span>
                <span class="s2">del </span><span class="s1">self._environment[key]</span>
        <span class="s2">return </span><span class="s1">old_env</span>

    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">custom_environment(self</span><span class="s2">, </span><span class="s1">**kwargs: Any) -&gt; Iterator[</span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot; 
        A context manager around the above ``update_environment`` method to restore the 
        environment back to its previous state after operation. 
 
        ``Examples``:: 
 
            with self.custom_environment(GIT_SSH='/bin/ssh_wrapper'): 
                repo.remotes.origin.fetch() 
 
        :param kwargs: see update_environment 
        &quot;&quot;&quot;</span>
        <span class="s1">old_env = self.update_environment(**kwargs)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.update_environment(**old_env)</span>

    <span class="s2">def </span><span class="s1">transform_kwarg(self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">value: Any</span><span class="s2">, </span><span class="s1">split_single_char_options: bool) -&gt; List[str]:</span>
        <span class="s2">if </span><span class="s1">len(name) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;-%s&quot; </span><span class="s1">% name]</span>
            <span class="s2">elif </span><span class="s1">value </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">False, None</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">split_single_char_options:</span>
                    <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;-%s&quot; </span><span class="s1">% name</span><span class="s2">, </span><span class="s3">&quot;%s&quot; </span><span class="s1">% value]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;-%s%s&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">value)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;--%s&quot; </span><span class="s1">% dashify(name)]</span>
            <span class="s2">elif </span><span class="s1">value </span><span class="s2">is not False and </span><span class="s1">value </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;--%s=%s&quot; </span><span class="s1">% (dashify(name)</span><span class="s2">, </span><span class="s1">value)]</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">transform_kwargs(self</span><span class="s2">, </span><span class="s1">split_single_char_options: bool = </span><span class="s2">True, </span><span class="s1">**kwargs: Any) -&gt; List[str]:</span>
        <span class="s4">&quot;&quot;&quot;Transforms Python style kwargs into git command line options.&quot;&quot;&quot;</span>
        <span class="s1">args = []</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items():</span>
            <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">v:</span>
                    <span class="s1">args += self.transform_kwarg(k</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">split_single_char_options)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args += self.transform_kwarg(k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">split_single_char_options)</span>
        <span class="s2">return </span><span class="s1">args</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_unpack_args(cls</span><span class="s2">, </span><span class="s1">arg_list: Sequence[str]) -&gt; List[str]:</span>

        <span class="s1">outlist = []</span>
        <span class="s2">if </span><span class="s1">isinstance(arg_list</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">arg_list:</span>
                <span class="s1">outlist.extend(cls._unpack_args(arg))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">outlist.append(str(arg_list))</span>

        <span class="s2">return </span><span class="s1">outlist</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">**kwargs: Any) -&gt; </span><span class="s3">&quot;Git&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Specify command line options to the git executable 
        for a subcommand call 
 
        :param kwargs: 
            is a dict of keyword arguments. 
            these arguments are passed as in _call_process 
            but will be passed to the git command rather than 
            the subcommand. 
 
        ``Examples``:: 
            git(work_tree='/tmp').difftool()&quot;&quot;&quot;</span>
        <span class="s1">self._git_options = self.transform_kwargs(split_single_char_options=</span><span class="s2">True, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">_call_process(self</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*args: </span><span class="s2">None, </span><span class="s1">**kwargs: </span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s1">...  </span><span class="s0"># if no args given, execute called with all defaults</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">_call_process(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">method: str</span><span class="s2">,</span>
        <span class="s1">istream: int</span><span class="s2">,</span>
        <span class="s1">as_process: Literal[</span><span class="s2">True</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">*args: Any</span><span class="s2">,</span>
        <span class="s1">**kwargs: Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s1">:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">_call_process(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*args: Any</span><span class="s2">, </span><span class="s1">**kwargs: Any</span>
    <span class="s1">) -&gt; Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">Union[str</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s1">]:</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">_call_process(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">method: str</span><span class="s2">, </span><span class="s1">*args: Any</span><span class="s2">, </span><span class="s1">**kwargs: Any</span>
    <span class="s1">) -&gt; Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">Tuple[int</span><span class="s2">, </span><span class="s1">Union[str</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Run the given git command with the specified arguments and return 
        the result as a String 
 
        :param method: 
            is the command. Contained &quot;_&quot; characters will be converted to dashes, 
            such as in 'ls_files' to call 'ls-files'. 
 
        :param args: 
            is the list of arguments. If None is included, it will be pruned. 
            This allows your commands to call git more conveniently as None 
            is realized as non-existent 
 
        :param kwargs: 
            It contains key-values for the following: 
            - the :meth:`execute()` kwds, as listed in :var:`execute_kwargs`; 
            - &quot;command options&quot; to be converted by :meth:`transform_kwargs()`; 
            - the `'insert_kwargs_after'` key which its value must match one of ``*args`` 
            and any cmd-options will be appended after the matched arg. 
 
        Examples:: 
 
            git.rev_list('master', max_count=10, header=True) 
 
        turns into:: 
 
           git rev-list max-count 10 --header master 
 
        :return: Same as ``execute`` 
                 if no args given used execute default (esp. as_process = False, stdout_as_string = True) 
                 and return str&quot;&quot;&quot;</span>
        <span class="s0"># Handle optional arguments prior to calling transform_kwargs</span>
        <span class="s0"># otherwise these'll end up in args, which is bad.</span>
        <span class="s1">exec_kwargs = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">execute_kwargs}</span>
        <span class="s1">opts_kwargs = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">execute_kwargs}</span>

        <span class="s1">insert_after_this_arg = opts_kwargs.pop(</span><span class="s3">&quot;insert_kwargs_after&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s0"># Prepare the argument list</span>

        <span class="s1">opt_args = self.transform_kwargs(**opts_kwargs)</span>
        <span class="s1">ext_args = self._unpack_args([a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">args </span><span class="s2">if </span><span class="s1">a </span><span class="s2">is not None</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">insert_after_this_arg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">args_list = opt_args + ext_args</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">index = ext_args.index(insert_after_this_arg)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Couldn't find argument '%s' in args %s to insert cmd options after&quot;</span>
                    <span class="s1">% (insert_after_this_arg</span><span class="s2">, </span><span class="s1">str(ext_args))</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s0"># end handle error</span>
            <span class="s1">args_list = ext_args[: index + </span><span class="s5">1</span><span class="s1">] + opt_args + ext_args[index + </span><span class="s5">1 </span><span class="s1">:]</span>
        <span class="s0"># end handle opts_kwargs</span>

        <span class="s1">call = [self.GIT_PYTHON_GIT_EXECUTABLE]</span>

        <span class="s0"># add persistent git options</span>
        <span class="s1">call.extend(self._persistent_git_options)</span>

        <span class="s0"># add the git options, then reset to empty</span>
        <span class="s0"># to avoid side_effects</span>
        <span class="s1">call.extend(self._git_options)</span>
        <span class="s1">self._git_options = ()</span>

        <span class="s1">call.append(dashify(method))</span>
        <span class="s1">call.extend(args_list)</span>

        <span class="s2">return </span><span class="s1">self.execute(call</span><span class="s2">, </span><span class="s1">**exec_kwargs)</span>

    <span class="s2">def </span><span class="s1">_parse_object_header(self</span><span class="s2">, </span><span class="s1">header_line: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s4">&quot;&quot;&quot; 
        :param header_line: 
            &lt;hex_sha&gt; type_string size_as_int 
 
        :return: (hex_sha, type_string, size_as_int) 
 
        :raise ValueError: if the header contains indication for an error due to 
            incorrect input sha&quot;&quot;&quot;</span>
        <span class="s1">tokens = header_line.split()</span>
        <span class="s2">if </span><span class="s1">len(tokens) != </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">tokens:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;SHA could not be resolved, git returned: %r&quot; </span><span class="s1">% (header_line.strip()))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;SHA %s could not be resolved, git returned: %r&quot; </span><span class="s1">% (tokens[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">header_line.strip()))</span>
            <span class="s0"># END handle actual return value</span>
        <span class="s0"># END error handling</span>

        <span class="s2">if </span><span class="s1">len(tokens[</span><span class="s5">0</span><span class="s1">]) != </span><span class="s5">40</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Failed to parse header: %r&quot; </span><span class="s1">% header_line)</span>
        <span class="s2">return </span><span class="s1">(tokens[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tokens[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int(tokens[</span><span class="s5">2</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">_prepare_ref(self</span><span class="s2">, </span><span class="s1">ref: AnyStr) -&gt; bytes:</span>
        <span class="s0"># required for command to separate refs on stdin, as bytes</span>
        <span class="s2">if </span><span class="s1">isinstance(ref</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s0"># Assume 40 bytes hexsha - bin-to-ascii for some reason returns bytes, not text</span>
            <span class="s1">refstr: str = ref.decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(ref</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">refstr = str(ref)  </span><span class="s0"># could be ref-object</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">refstr = ref</span>

        <span class="s2">if not </span><span class="s1">refstr.endswith(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">):</span>
            <span class="s1">refstr += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s2">return </span><span class="s1">refstr.encode(defenc)</span>

    <span class="s2">def </span><span class="s1">_get_persistent_cmd(self</span><span class="s2">, </span><span class="s1">attr_name: str</span><span class="s2">, </span><span class="s1">cmd_name: str</span><span class="s2">, </span><span class="s1">*args: Any</span><span class="s2">, </span><span class="s1">**kwargs: Any) -&gt; </span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s1">:</span>
        <span class="s1">cur_val = getattr(self</span><span class="s2">, </span><span class="s1">attr_name)</span>
        <span class="s2">if </span><span class="s1">cur_val </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cur_val</span>

        <span class="s1">options = {</span><span class="s3">&quot;istream&quot;</span><span class="s1">: PIPE</span><span class="s2">, </span><span class="s3">&quot;as_process&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
        <span class="s1">options.update(kwargs)</span>

        <span class="s1">cmd = self._call_process(cmd_name</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**options)</span>
        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">cmd)</span>
        <span class="s1">cmd = cast(</span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s2">, </span><span class="s1">cmd)</span>
        <span class="s2">return </span><span class="s1">cmd</span>

    <span class="s2">def </span><span class="s1">__get_object_header(self</span><span class="s2">, </span><span class="s1">cmd: </span><span class="s3">&quot;Git.AutoInterrupt&quot;</span><span class="s2">, </span><span class="s1">ref: AnyStr) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s2">if </span><span class="s1">cmd.stdin </span><span class="s2">and </span><span class="s1">cmd.stdout:</span>
            <span class="s1">cmd.stdin.write(self._prepare_ref(ref))</span>
            <span class="s1">cmd.stdin.flush()</span>
            <span class="s2">return </span><span class="s1">self._parse_object_header(cmd.stdout.readline())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cmd stdin was empty&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_object_header(self</span><span class="s2">, </span><span class="s1">ref: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int]:</span>
        <span class="s4">&quot;&quot;&quot;Use this method to quickly examine the type and size of the object behind 
        the given ref. 
 
        :note: The method will only suffer from the costs of command invocation 
            once and reuses the command in subsequent calls. 
 
        :return: (hexsha, type_string, size_as_int)&quot;&quot;&quot;</span>
        <span class="s1">cmd = self._get_persistent_cmd(</span><span class="s3">&quot;cat_file_header&quot;</span><span class="s2">, </span><span class="s3">&quot;cat_file&quot;</span><span class="s2">, </span><span class="s1">batch_check=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__get_object_header(cmd</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s2">def </span><span class="s1">get_object_data(self</span><span class="s2">, </span><span class="s1">ref: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">bytes]:</span>
        <span class="s4">&quot;&quot;&quot;As get_object_header, but returns object data as well 
 
        :return: (hexsha, type_string, size_as_int, data_string) 
        :note: not threadsafe&quot;&quot;&quot;</span>
        <span class="s1">hexsha</span><span class="s2">, </span><span class="s1">typename</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">stream = self.stream_object_data(ref)</span>
        <span class="s1">data = stream.read(size)</span>
        <span class="s2">del </span><span class="s1">stream</span>
        <span class="s2">return </span><span class="s1">(hexsha</span><span class="s2">, </span><span class="s1">typename</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s2">def </span><span class="s1">stream_object_data(self</span><span class="s2">, </span><span class="s1">ref: str) -&gt; Tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s3">&quot;Git.CatFileContentStream&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;As get_object_header, but returns the data as a stream 
 
        :return: (hexsha, type_string, size_as_int, stream) 
        :note: This method is not threadsafe, you need one independent Command instance per thread to be safe !&quot;&quot;&quot;</span>
        <span class="s1">cmd = self._get_persistent_cmd(</span><span class="s3">&quot;cat_file_all&quot;</span><span class="s2">, </span><span class="s3">&quot;cat_file&quot;</span><span class="s2">, </span><span class="s1">batch=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">hexsha</span><span class="s2">, </span><span class="s1">typename</span><span class="s2">, </span><span class="s1">size = self.__get_object_header(cmd</span><span class="s2">, </span><span class="s1">ref)</span>
        <span class="s1">cmd_stdout = cmd.stdout </span><span class="s2">if </span><span class="s1">cmd.stdout </span><span class="s2">is not None else </span><span class="s1">io.BytesIO()</span>
        <span class="s2">return </span><span class="s1">(hexsha</span><span class="s2">, </span><span class="s1">typename</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">self.CatFileContentStream(size</span><span class="s2">, </span><span class="s1">cmd_stdout))</span>

    <span class="s2">def </span><span class="s1">clear_cache(self) -&gt; </span><span class="s3">&quot;Git&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Clear all kinds of internal caches to release resources. 
 
        Currently persistent commands will be interrupted. 
 
        :return: self&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">(self.cat_file_all</span><span class="s2">, </span><span class="s1">self.cat_file_header):</span>
            <span class="s2">if </span><span class="s1">cmd:</span>
                <span class="s1">cmd.__del__()</span>

        <span class="s1">self.cat_file_all = </span><span class="s2">None</span>
        <span class="s1">self.cat_file_header = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span>
</pre>
</body>
</html>