<html>
<head>
<title>typing_extensions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typing_extensions.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">collections.abc</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">types </span><span class="s0">as </span><span class="s1">_types</span>
<span class="s0">import </span><span class="s1">typing</span>


<span class="s1">__all__ = [</span>
    <span class="s2"># Super-special typing primitives.</span>
    <span class="s3">'Any'</span><span class="s0">,</span>
    <span class="s3">'ClassVar'</span><span class="s0">,</span>
    <span class="s3">'Concatenate'</span><span class="s0">,</span>
    <span class="s3">'Final'</span><span class="s0">,</span>
    <span class="s3">'LiteralString'</span><span class="s0">,</span>
    <span class="s3">'ParamSpec'</span><span class="s0">,</span>
    <span class="s3">'ParamSpecArgs'</span><span class="s0">,</span>
    <span class="s3">'ParamSpecKwargs'</span><span class="s0">,</span>
    <span class="s3">'Self'</span><span class="s0">,</span>
    <span class="s3">'Type'</span><span class="s0">,</span>
    <span class="s3">'TypeVar'</span><span class="s0">,</span>
    <span class="s3">'TypeVarTuple'</span><span class="s0">,</span>
    <span class="s3">'Unpack'</span><span class="s0">,</span>

    <span class="s2"># ABCs (from collections.abc).</span>
    <span class="s3">'Awaitable'</span><span class="s0">,</span>
    <span class="s3">'AsyncIterator'</span><span class="s0">,</span>
    <span class="s3">'AsyncIterable'</span><span class="s0">,</span>
    <span class="s3">'Coroutine'</span><span class="s0">,</span>
    <span class="s3">'AsyncGenerator'</span><span class="s0">,</span>
    <span class="s3">'AsyncContextManager'</span><span class="s0">,</span>
    <span class="s3">'ChainMap'</span><span class="s0">,</span>

    <span class="s2"># Concrete collection types.</span>
    <span class="s3">'ContextManager'</span><span class="s0">,</span>
    <span class="s3">'Counter'</span><span class="s0">,</span>
    <span class="s3">'Deque'</span><span class="s0">,</span>
    <span class="s3">'DefaultDict'</span><span class="s0">,</span>
    <span class="s3">'NamedTuple'</span><span class="s0">,</span>
    <span class="s3">'OrderedDict'</span><span class="s0">,</span>
    <span class="s3">'TypedDict'</span><span class="s0">,</span>

    <span class="s2"># Structural checks, a.k.a. protocols.</span>
    <span class="s3">'SupportsIndex'</span><span class="s0">,</span>

    <span class="s2"># One-off things.</span>
    <span class="s3">'Annotated'</span><span class="s0">,</span>
    <span class="s3">'assert_never'</span><span class="s0">,</span>
    <span class="s3">'assert_type'</span><span class="s0">,</span>
    <span class="s3">'clear_overloads'</span><span class="s0">,</span>
    <span class="s3">'dataclass_transform'</span><span class="s0">,</span>
    <span class="s3">'get_overloads'</span><span class="s0">,</span>
    <span class="s3">'final'</span><span class="s0">,</span>
    <span class="s3">'get_args'</span><span class="s0">,</span>
    <span class="s3">'get_origin'</span><span class="s0">,</span>
    <span class="s3">'get_type_hints'</span><span class="s0">,</span>
    <span class="s3">'IntVar'</span><span class="s0">,</span>
    <span class="s3">'is_typeddict'</span><span class="s0">,</span>
    <span class="s3">'Literal'</span><span class="s0">,</span>
    <span class="s3">'NewType'</span><span class="s0">,</span>
    <span class="s3">'overload'</span><span class="s0">,</span>
    <span class="s3">'override'</span><span class="s0">,</span>
    <span class="s3">'Protocol'</span><span class="s0">,</span>
    <span class="s3">'reveal_type'</span><span class="s0">,</span>
    <span class="s3">'runtime'</span><span class="s0">,</span>
    <span class="s3">'runtime_checkable'</span><span class="s0">,</span>
    <span class="s3">'Text'</span><span class="s0">,</span>
    <span class="s3">'TypeAlias'</span><span class="s0">,</span>
    <span class="s3">'TypeGuard'</span><span class="s0">,</span>
    <span class="s3">'TYPE_CHECKING'</span><span class="s0">,</span>
    <span class="s3">'Never'</span><span class="s0">,</span>
    <span class="s3">'NoReturn'</span><span class="s0">,</span>
    <span class="s3">'Required'</span><span class="s0">,</span>
    <span class="s3">'NotRequired'</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s2"># for backward compatibility</span>
<span class="s1">PEP_560 = </span><span class="s0">True</span>
<span class="s1">GenericMeta = type</span>

<span class="s2"># The functions below are modified copies of typing internal helpers.</span>
<span class="s2"># They are needed by _ProtocolMeta and they provide support for PEP 646.</span>

<span class="s1">_marker = object()</span>


<span class="s0">def </span><span class="s1">_check_generic(cls</span><span class="s0">, </span><span class="s1">parameters</span><span class="s0">, </span><span class="s1">elen=_marker):</span>
    <span class="s4">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper). 
    This gives a nice error message in case of count mismatch. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">elen:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s3">is not a generic class&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">elen </span><span class="s0">is </span><span class="s1">_marker:</span>
        <span class="s0">if not </span><span class="s1">hasattr(cls</span><span class="s0">, </span><span class="s3">&quot;__parameters__&quot;</span><span class="s1">) </span><span class="s0">or not </span><span class="s1">cls.__parameters__:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">} </span><span class="s3">is not a generic class&quot;</span><span class="s1">)</span>
        <span class="s1">elen = len(cls.__parameters__)</span>
    <span class="s1">alen = len(parameters)</span>
    <span class="s0">if </span><span class="s1">alen != elen:</span>
        <span class="s0">if </span><span class="s1">hasattr(cls</span><span class="s0">, </span><span class="s3">&quot;__parameters__&quot;</span><span class="s1">):</span>
            <span class="s1">parameters = [p </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">cls.__parameters__ </span><span class="s0">if not </span><span class="s1">_is_unpack(p)]</span>
            <span class="s1">num_tv_tuples = sum(isinstance(p</span><span class="s0">, </span><span class="s1">TypeVarTuple) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters)</span>
            <span class="s0">if </span><span class="s1">(num_tv_tuples &gt; </span><span class="s5">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(alen &gt;= elen - num_tv_tuples):</span>
                <span class="s0">return</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Too </span><span class="s0">{</span><span class="s3">'many' </span><span class="s0">if </span><span class="s1">alen &gt; elen </span><span class="s0">else </span><span class="s3">'few'</span><span class="s0">} </span><span class="s3">parameters for </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s3">;&quot;</span>
                        <span class="s3">f&quot; actual </span><span class="s0">{</span><span class="s1">alen</span><span class="s0">}</span><span class="s3">, expected </span><span class="s0">{</span><span class="s1">elen</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters(t):</span>
        <span class="s0">return </span><span class="s1">isinstance(</span>
            <span class="s1">t</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_types.GenericAlias</span><span class="s0">, </span><span class="s1">_types.UnionType)</span>
        <span class="s1">)</span>
<span class="s0">elif </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters(t):</span>
        <span class="s0">return </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_types.GenericAlias))</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_should_collect_from_parameters(t):</span>
        <span class="s0">return </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typing._GenericAlias) </span><span class="s0">and not </span><span class="s1">t._special</span>


<span class="s0">def </span><span class="s1">_collect_type_vars(types</span><span class="s0">, </span><span class="s1">typevar_types=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Collect all type variable contained in types in order of 
    first appearance (lexicographic order). For example:: 
 
        _collect_type_vars((T, List[S, T])) == (T, S) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">typevar_types </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">typevar_types = typing.TypeVar</span>
    <span class="s1">tvars = []</span>
    <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types:</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typevar_types) </span><span class="s0">and</span>
            <span class="s1">t </span><span class="s0">not in </span><span class="s1">tvars </span><span class="s0">and</span>
            <span class="s0">not </span><span class="s1">_is_unpack(t)</span>
        <span class="s1">):</span>
            <span class="s1">tvars.append(t)</span>
        <span class="s0">if </span><span class="s1">_should_collect_from_parameters(t):</span>
            <span class="s1">tvars.extend([t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">t.__parameters__ </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">tvars])</span>
    <span class="s0">return </span><span class="s1">tuple(tvars)</span>


<span class="s1">NoReturn = typing.NoReturn</span>

<span class="s2"># Some unconstrained type variables.  These are used by the container types.</span>
<span class="s2"># (These are not for export.)</span>
<span class="s1">T = typing.TypeVar(</span><span class="s3">'T'</span><span class="s1">)  </span><span class="s2"># Any type.</span>
<span class="s1">KT = typing.TypeVar(</span><span class="s3">'KT'</span><span class="s1">)  </span><span class="s2"># Key type.</span>
<span class="s1">VT = typing.TypeVar(</span><span class="s3">'VT'</span><span class="s1">)  </span><span class="s2"># Value type.</span>
<span class="s1">T_co = typing.TypeVar(</span><span class="s3">'T_co'</span><span class="s0">, </span><span class="s1">covariant=</span><span class="s0">True</span><span class="s1">)  </span><span class="s2"># Any type covariant containers.</span>
<span class="s1">T_contra = typing.TypeVar(</span><span class="s3">'T_contra'</span><span class="s0">, </span><span class="s1">contravariant=</span><span class="s0">True</span><span class="s1">)  </span><span class="s2"># Ditto contravariant.</span>


<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">11</span><span class="s1">):</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s0">class </span><span class="s1">_AnyMeta(type):</span>
        <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Any:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;typing_extensions.Any cannot be used with isinstance()&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__instancecheck__(obj)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is </span><span class="s1">Any:</span>
                <span class="s0">return </span><span class="s3">&quot;typing_extensions.Any&quot;</span>
            <span class="s0">return </span><span class="s1">super().__repr__()</span>

    <span class="s0">class </span><span class="s1">Any(metaclass=_AnyMeta):</span>
        <span class="s4">&quot;&quot;&quot;Special type indicating an unconstrained type. 
        - Any is compatible with every type. 
        - Any assumed to have all methods. 
        - All values assumed to be instances of Any. 
        Note that all the above statements are true from the point of view of 
        static type checkers. At runtime, Any should not be used with instance 
        checks. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Any:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Any cannot be instantiated&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">ClassVar = typing.ClassVar</span>

<span class="s2"># On older versions of typing there is an internal class named &quot;Final&quot;.</span>
<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Final'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">7</span><span class="s1">):</span>
    <span class="s1">Final = typing.Final</span>
<span class="s2"># 3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_FinalForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Final = _FinalForm(</span><span class="s3">'Final'</span><span class="s0">,</span>
                       <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to indicate that a name 
                       cannot be re-assigned or overridden in a subclass. 
                       For example: 
 
                           MAX_SIZE: Final = 9000 
                           MAX_SIZE += 1  # Error reported by type checker 
 
                           class Connection: 
                               TIMEOUT: Final[int] = 10 
                           class FastConnector(Connection): 
                               TIMEOUT = 1  # Error reported by type checker 
 
                       There is no runtime checking of these properties.&quot;&quot;&quot;</span><span class="s1">)</span>

<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">11</span><span class="s1">):</span>
    <span class="s1">final = typing.final</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># @final exists in 3.8+, but we backport it for all versions</span>
    <span class="s2"># before 3.11 to keep support for the __final__ attribute.</span>
    <span class="s2"># See https://bugs.python.org/issue46342</span>
    <span class="s0">def </span><span class="s1">final(f):</span>
        <span class="s4">&quot;&quot;&quot;This decorator can be used to indicate to type checkers that 
        the decorated method cannot be overridden, and decorated class 
        cannot be subclassed. For example: 
 
            class Base: 
                @final 
                def done(self) -&gt; None: 
                    ... 
            class Sub(Base): 
                def done(self) -&gt; None:  # Error reported by type checker 
                    ... 
            @final 
            class Leaf: 
                ... 
            class Other(Leaf):  # Error reported by type checker 
                ... 
 
        There is no runtime checking of these properties. The decorator 
        sets the ``__final__`` attribute to ``True`` on the decorated object 
        to allow runtime introspection. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">f.__final__ = </span><span class="s0">True</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">TypeError):</span>
            <span class="s2"># Skip the attribute silently if it is not writable.</span>
            <span class="s2"># AttributeError happens if the object has __slots__ or a</span>
            <span class="s2"># read-only property, TypeError if it's a builtin class.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">f</span>


<span class="s0">def </span><span class="s1">IntVar(name):</span>
    <span class="s0">return </span><span class="s1">typing.TypeVar(name)</span>


<span class="s2"># 3.8+:</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Literal'</span><span class="s1">):</span>
    <span class="s1">Literal = typing.Literal</span>
<span class="s2"># 3.7:</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_LiteralForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Literal = _LiteralForm(</span><span class="s3">'Literal'</span><span class="s0">,</span>
                           <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A type that can be used to indicate to type checkers 
                           that the corresponding value has a value literally equivalent 
                           to the provided parameter. For example: 
 
                               var: Literal[4] = 4 
 
                           The type checker understands that 'var' is literally equal to 
                           the value 4 and no other value. 
 
                           Literal[...] cannot be subclassed. There is no runtime 
                           checking verifying that the parameter is actually a value 
                           instead of a type.&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s1">_overload_dummy = typing._overload_dummy  </span><span class="s2"># noqa</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;get_overloads&quot;</span><span class="s1">):  </span><span class="s2"># 3.11+</span>
    <span class="s1">overload = typing.overload</span>
    <span class="s1">get_overloads = typing.get_overloads</span>
    <span class="s1">clear_overloads = typing.clear_overloads</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s2"># {module: {qualname: {firstlineno: func}}}</span>
    <span class="s1">_overload_registry = collections.defaultdict(</span>
        <span class="s1">functools.partial(collections.defaultdict</span><span class="s0">, </span><span class="s1">dict)</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">overload(func):</span>
        <span class="s4">&quot;&quot;&quot;Decorator for overloaded functions/methods. 
 
        In a stub file, place two or more stub definitions for the same 
        function in a row, each decorated with @overload.  For example: 
 
        @overload 
        def utf8(value: None) -&gt; None: ... 
        @overload 
        def utf8(value: bytes) -&gt; bytes: ... 
        @overload 
        def utf8(value: str) -&gt; bytes: ... 
 
        In a non-stub file (i.e. a regular .py file), do the same but 
        follow it with an implementation.  The implementation should *not* 
        be decorated with @overload.  For example: 
 
        @overload 
        def utf8(value: None) -&gt; None: ... 
        @overload 
        def utf8(value: bytes) -&gt; bytes: ... 
        @overload 
        def utf8(value: str) -&gt; bytes: ... 
        def utf8(value): 
            # implementation goes here 
 
        The overloads for a function can be retrieved at runtime using the 
        get_overloads() function. 
        &quot;&quot;&quot;</span>
        <span class="s2"># classmethod and staticmethod</span>
        <span class="s1">f = getattr(func</span><span class="s0">, </span><span class="s3">&quot;__func__&quot;</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">_overload_registry[f.__module__][f.__qualname__][</span>
                <span class="s1">f.__code__.co_firstlineno</span>
            <span class="s1">] = func</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># Not a normal function; ignore.</span>
            <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">_overload_dummy</span>

    <span class="s0">def </span><span class="s1">get_overloads(func):</span>
        <span class="s4">&quot;&quot;&quot;Return all defined overloads for *func* as a sequence.&quot;&quot;&quot;</span>
        <span class="s2"># classmethod and staticmethod</span>
        <span class="s1">f = getattr(func</span><span class="s0">, </span><span class="s3">&quot;__func__&quot;</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s0">if </span><span class="s1">f.__module__ </span><span class="s0">not in </span><span class="s1">_overload_registry:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s1">mod_dict = _overload_registry[f.__module__]</span>
        <span class="s0">if </span><span class="s1">f.__qualname__ </span><span class="s0">not in </span><span class="s1">mod_dict:</span>
            <span class="s0">return </span><span class="s1">[]</span>
        <span class="s0">return </span><span class="s1">list(mod_dict[f.__qualname__].values())</span>

    <span class="s0">def </span><span class="s1">clear_overloads():</span>
        <span class="s4">&quot;&quot;&quot;Clear all overloads in the registry.&quot;&quot;&quot;</span>
        <span class="s1">_overload_registry.clear()</span>


<span class="s2"># This is not a real generic class.  Don't use outside annotations.</span>
<span class="s1">Type = typing.Type</span>

<span class="s2"># Various ABCs mimicking those in collections.abc.</span>
<span class="s2"># A few are simply re-exported for completeness.</span>


<span class="s1">Awaitable = typing.Awaitable</span>
<span class="s1">Coroutine = typing.Coroutine</span>
<span class="s1">AsyncIterable = typing.AsyncIterable</span>
<span class="s1">AsyncIterator = typing.AsyncIterator</span>
<span class="s1">Deque = typing.Deque</span>
<span class="s1">ContextManager = typing.ContextManager</span>
<span class="s1">AsyncContextManager = typing.AsyncContextManager</span>
<span class="s1">DefaultDict = typing.DefaultDict</span>

<span class="s2"># 3.7.2+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'OrderedDict'</span><span class="s1">):</span>
    <span class="s1">OrderedDict = typing.OrderedDict</span>
<span class="s2"># 3.7.0-3.7.2</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">OrderedDict = typing._alias(collections.OrderedDict</span><span class="s0">, </span><span class="s1">(KT</span><span class="s0">, </span><span class="s1">VT))</span>

<span class="s1">Counter = typing.Counter</span>
<span class="s1">ChainMap = typing.ChainMap</span>
<span class="s1">AsyncGenerator = typing.AsyncGenerator</span>
<span class="s1">NewType = typing.NewType</span>
<span class="s1">Text = typing.Text</span>
<span class="s1">TYPE_CHECKING = typing.TYPE_CHECKING</span>


<span class="s1">_PROTO_WHITELIST = [</span><span class="s3">'Callable'</span><span class="s0">, </span><span class="s3">'Awaitable'</span><span class="s0">,</span>
                    <span class="s3">'Iterable'</span><span class="s0">, </span><span class="s3">'Iterator'</span><span class="s0">, </span><span class="s3">'AsyncIterable'</span><span class="s0">, </span><span class="s3">'AsyncIterator'</span><span class="s0">,</span>
                    <span class="s3">'Hashable'</span><span class="s0">, </span><span class="s3">'Sized'</span><span class="s0">, </span><span class="s3">'Container'</span><span class="s0">, </span><span class="s3">'Collection'</span><span class="s0">, </span><span class="s3">'Reversible'</span><span class="s0">,</span>
                    <span class="s3">'ContextManager'</span><span class="s0">, </span><span class="s3">'AsyncContextManager'</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_get_protocol_attrs(cls):</span>
    <span class="s1">attrs = set()</span>
    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__mro__[:-</span><span class="s5">1</span><span class="s1">]:  </span><span class="s2"># without object</span>
        <span class="s0">if </span><span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'Protocol'</span><span class="s0">, </span><span class="s3">'Generic'</span><span class="s1">):</span>
            <span class="s0">continue</span>
        <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">list(base.__dict__.keys()) + list(annotations.keys()):</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">attr.startswith(</span><span class="s3">'_abc_'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">attr </span><span class="s0">not in </span><span class="s1">(</span>
                    <span class="s3">'__abstractmethods__'</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s3">'__weakref__'</span><span class="s0">,</span>
                    <span class="s3">'_is_protocol'</span><span class="s0">, </span><span class="s3">'_is_runtime_protocol'</span><span class="s0">, </span><span class="s3">'__dict__'</span><span class="s0">,</span>
                    <span class="s3">'__args__'</span><span class="s0">, </span><span class="s3">'__slots__'</span><span class="s0">,</span>
                    <span class="s3">'__next_in_mro__'</span><span class="s0">, </span><span class="s3">'__parameters__'</span><span class="s0">, </span><span class="s3">'__origin__'</span><span class="s0">,</span>
                    <span class="s3">'__orig_bases__'</span><span class="s0">, </span><span class="s3">'__extra__'</span><span class="s0">, </span><span class="s3">'__tree_hash__'</span><span class="s0">,</span>
                    <span class="s3">'__doc__'</span><span class="s0">, </span><span class="s3">'__subclasshook__'</span><span class="s0">, </span><span class="s3">'__init__'</span><span class="s0">, </span><span class="s3">'__new__'</span><span class="s0">,</span>
                    <span class="s3">'__module__'</span><span class="s0">, </span><span class="s3">'_MutableMapping__marker'</span><span class="s0">, </span><span class="s3">'_gorg'</span><span class="s1">)):</span>
                <span class="s1">attrs.add(attr)</span>
    <span class="s0">return </span><span class="s1">attrs</span>


<span class="s0">def </span><span class="s1">_is_callable_members_only(cls):</span>
    <span class="s0">return </span><span class="s1">all(callable(getattr(cls</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls))</span>


<span class="s0">def </span><span class="s1">_maybe_adjust_parameters(cls):</span>
    <span class="s4">&quot;&quot;&quot;Helper function used in Protocol.__init_subclass__ and _TypedDictMeta.__new__. 
 
    The contents of this function are very similar 
    to logic found in typing.Generic.__init_subclass__ 
    on the CPython main branch. 
    &quot;&quot;&quot;</span>
    <span class="s1">tvars = []</span>
    <span class="s0">if </span><span class="s3">'__orig_bases__' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
        <span class="s1">tvars = typing._collect_type_vars(cls.__orig_bases__)</span>
        <span class="s2"># Look for Generic[T1, ..., Tn] or Protocol[T1, ..., Tn].</span>
        <span class="s2"># If found, tvars must be a subset of it.</span>
        <span class="s2"># If not found, tvars is it.</span>
        <span class="s2"># Also check for and reject plain Generic,</span>
        <span class="s2"># and reject multiple Generic[...] and/or Protocol[...].</span>
        <span class="s1">gvars = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__orig_bases__:</span>
            <span class="s0">if </span><span class="s1">(isinstance(base</span><span class="s0">, </span><span class="s1">typing._GenericAlias) </span><span class="s0">and</span>
                    <span class="s1">base.__origin__ </span><span class="s0">in </span><span class="s1">(typing.Generic</span><span class="s0">, </span><span class="s1">Protocol)):</span>
                <span class="s2"># for error messages</span>
                <span class="s1">the_base = base.__origin__.__name__</span>
                <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Cannot inherit from Generic[...]&quot;</span>
                        <span class="s3">&quot; and/or Protocol[...] multiple types.&quot;</span><span class="s1">)</span>
                <span class="s1">gvars = base.__parameters__</span>
        <span class="s0">if </span><span class="s1">gvars </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">gvars = tvars</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tvarset = set(tvars)</span>
            <span class="s1">gvarset = set(gvars)</span>
            <span class="s0">if not </span><span class="s1">tvarset &lt;= gvarset:</span>
                <span class="s1">s_vars = </span><span class="s3">', '</span><span class="s1">.join(str(t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">tvars </span><span class="s0">if </span><span class="s1">t </span><span class="s0">not in </span><span class="s1">gvarset)</span>
                <span class="s1">s_args = </span><span class="s3">', '</span><span class="s1">.join(str(g) </span><span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">gvars)</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Some type variables (</span><span class="s0">{</span><span class="s1">s_vars</span><span class="s0">}</span><span class="s3">) are&quot;</span>
                                <span class="s3">f&quot; not listed in </span><span class="s0">{</span><span class="s1">the_base</span><span class="s0">}</span><span class="s3">[</span><span class="s0">{</span><span class="s1">s_args</span><span class="s0">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
            <span class="s1">tvars = gvars</span>
    <span class="s1">cls.__parameters__ = tuple(tvars)</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Protocol'</span><span class="s1">):</span>
    <span class="s1">Protocol = typing.Protocol</span>
<span class="s2"># 3.7</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s0">def </span><span class="s1">_no_init(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">type(self)._is_protocol:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'Protocols cannot be instantiated'</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">_ProtocolMeta(abc.ABCMeta):  </span><span class="s2"># noqa: B024</span>
        <span class="s2"># This metaclass is a bit unfortunate and exists only because of the lack</span>
        <span class="s2"># of __instancehook__.</span>
        <span class="s0">def </span><span class="s1">__instancecheck__(cls</span><span class="s0">, </span><span class="s1">instance):</span>
            <span class="s2"># We need this method for situations where attributes are</span>
            <span class="s2"># assigned in __init__.</span>
            <span class="s0">if </span><span class="s1">((</span><span class="s0">not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">'_is_protocol'</span><span class="s0">, False</span><span class="s1">) </span><span class="s0">or</span>
                 <span class="s1">_is_callable_members_only(cls)) </span><span class="s0">and</span>
                    <span class="s1">issubclass(instance.__class__</span><span class="s0">, </span><span class="s1">cls)):</span>
                <span class="s0">return True</span>
            <span class="s0">if </span><span class="s1">cls._is_protocol:</span>
                <span class="s0">if </span><span class="s1">all(hasattr(instance</span><span class="s0">, </span><span class="s1">attr) </span><span class="s0">and</span>
                       <span class="s1">(</span><span class="s0">not </span><span class="s1">callable(getattr(cls</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, None</span><span class="s1">)) </span><span class="s0">or</span>
                        <span class="s1">getattr(instance</span><span class="s0">, </span><span class="s1">attr) </span><span class="s0">is not None</span><span class="s1">)</span>
                       <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls)):</span>
                    <span class="s0">return True</span>
            <span class="s0">return </span><span class="s1">super().__instancecheck__(instance)</span>

    <span class="s0">class </span><span class="s1">Protocol(metaclass=_ProtocolMeta):</span>
        <span class="s2"># There is quite a lot of overlapping code with typing.Generic.</span>
        <span class="s2"># Unfortunately it is hard to avoid this while these live in two different</span>
        <span class="s2"># modules. The duplicated code will be removed when Protocol is moved to typing.</span>
        <span class="s4">&quot;&quot;&quot;Base class for protocol classes. Protocol classes are defined as:: 
 
            class Proto(Protocol): 
                def meth(self) -&gt; int: 
                    ... 
 
        Such classes are primarily used with static type checkers that recognize 
        structural subtyping (static duck-typing), for example:: 
 
            class C: 
                def meth(self) -&gt; int: 
                    return 0 
 
            def func(x: Proto) -&gt; int: 
                return x.meth() 
 
            func(C())  # Passes static type check 
 
        See PEP 544 for details. Protocol classes decorated with 
        @typing_extensions.runtime act as simple-minded runtime protocol that checks 
        only the presence of given attributes, ignoring their type signatures. 
 
        Protocol classes can be generic, they are defined as:: 
 
            class GenProto(Protocol[T]): 
                def meth(self) -&gt; T: 
                    ... 
        &quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>
        <span class="s1">_is_protocol = </span><span class="s0">True</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Type Protocol cannot be instantiated; &quot;</span>
                                <span class="s3">&quot;it can only be used as a base class&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">super().__new__(cls)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__class_getitem__(cls</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">params = (params</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">params </span><span class="s0">and </span><span class="s1">cls </span><span class="s0">is not </span><span class="s1">typing.Tuple:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">f&quot;Parameter list to </span><span class="s0">{</span><span class="s1">cls.__qualname__</span><span class="s0">}</span><span class="s3">[...] cannot be empty&quot;</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s3">&quot;Parameters to generic types must be types.&quot;</span>
            <span class="s1">params = tuple(typing._type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params)  </span><span class="s2"># noqa</span>
            <span class="s0">if </span><span class="s1">cls </span><span class="s0">is </span><span class="s1">Protocol:</span>
                <span class="s2"># Generic can only be subscripted with unique type variables.</span>
                <span class="s0">if not </span><span class="s1">all(isinstance(p</span><span class="s0">, </span><span class="s1">typing.TypeVar) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">params):</span>
                    <span class="s1">i = </span><span class="s5">0</span>
                    <span class="s0">while </span><span class="s1">isinstance(params[i]</span><span class="s0">, </span><span class="s1">typing.TypeVar):</span>
                        <span class="s1">i += </span><span class="s5">1</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Parameters to Protocol[...] must all be type variables.&quot;</span>
                        <span class="s3">f&quot; Parameter </span><span class="s0">{</span><span class="s1">i + </span><span class="s5">1</span><span class="s0">} </span><span class="s3">is </span><span class="s0">{</span><span class="s1">params[i]</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(set(params)) != len(params):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Parameters to Protocol[...] must all be unique&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># Subscripting a regular Generic subclass.</span>
                <span class="s1">_check_generic(cls</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">len(cls.__parameters__))</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(cls</span><span class="s0">, </span><span class="s1">params)</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">if </span><span class="s3">'__orig_bases__' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
                <span class="s1">error = typing.Generic </span><span class="s0">in </span><span class="s1">cls.__orig_bases__</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">error = typing.Generic </span><span class="s0">in </span><span class="s1">cls.__bases__</span>
            <span class="s0">if </span><span class="s1">error:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot inherit from plain Generic&quot;</span><span class="s1">)</span>
            <span class="s1">_maybe_adjust_parameters(cls)</span>

            <span class="s2"># Determine if this is a protocol or a concrete subclass.</span>
            <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s3">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                <span class="s1">cls._is_protocol = any(b </span><span class="s0">is </span><span class="s1">Protocol </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">cls.__bases__)</span>

            <span class="s2"># Set (or override) the protocol subclass hook.</span>
            <span class="s0">def </span><span class="s1">_proto_hook(other):</span>
                <span class="s0">if not </span><span class="s1">cls.__dict__.get(</span><span class="s3">'_is_protocol'</span><span class="s0">, None</span><span class="s1">):</span>
                    <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">if not </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s3">'_is_runtime_protocol'</span><span class="s0">, False</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s5">2</span><span class="s1">).f_globals[</span><span class="s3">'__name__'</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'abc'</span><span class="s0">, </span><span class="s3">'functools'</span><span class="s1">]:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Instance and class checks can only be used with&quot;</span>
                                    <span class="s3">&quot; @runtime protocols&quot;</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">_is_callable_members_only(cls):</span>
                    <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s5">2</span><span class="s1">).f_globals[</span><span class="s3">'__name__'</span><span class="s1">] </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'abc'</span><span class="s0">, </span><span class="s3">'functools'</span><span class="s1">]:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Protocols with non-method members&quot;</span>
                                    <span class="s3">&quot; don't support issubclass()&quot;</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type):</span>
                    <span class="s2"># Same error as for issubclass(1, int)</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'issubclass() arg 1 must be a class'</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">_get_protocol_attrs(cls):</span>
                    <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">other.__mro__:</span>
                        <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">base.__dict__:</span>
                            <span class="s0">if </span><span class="s1">base.__dict__[attr] </span><span class="s0">is None</span><span class="s1">:</span>
                                <span class="s0">return </span><span class="s1">NotImplemented</span>
                            <span class="s0">break</span>
                        <span class="s1">annotations = getattr(base</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
                        <span class="s0">if </span><span class="s1">(isinstance(annotations</span><span class="s0">, </span><span class="s1">typing.Mapping) </span><span class="s0">and</span>
                                <span class="s1">attr </span><span class="s0">in </span><span class="s1">annotations </span><span class="s0">and</span>
                                <span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and</span>
                                <span class="s1">other._is_protocol):</span>
                            <span class="s0">break</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">return </span><span class="s1">NotImplemented</span>
                <span class="s0">return True</span>
            <span class="s0">if </span><span class="s3">'__subclasshook__' </span><span class="s0">not in </span><span class="s1">cls.__dict__:</span>
                <span class="s1">cls.__subclasshook__ = _proto_hook</span>

            <span class="s2"># We have nothing more to do for non-protocols.</span>
            <span class="s0">if not </span><span class="s1">cls._is_protocol:</span>
                <span class="s0">return</span>

            <span class="s2"># Check consistency of bases.</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__bases__:</span>
                <span class="s0">if not </span><span class="s1">(base </span><span class="s0">in </span><span class="s1">(object</span><span class="s0">, </span><span class="s1">typing.Generic) </span><span class="s0">or</span>
                        <span class="s1">base.__module__ == </span><span class="s3">'collections.abc' </span><span class="s0">and</span>
                        <span class="s1">base.__name__ </span><span class="s0">in </span><span class="s1">_PROTO_WHITELIST </span><span class="s0">or</span>
                        <span class="s1">isinstance(base</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">and </span><span class="s1">base._is_protocol):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'Protocols can only inherit from other'</span>
                                    <span class="s3">f' protocols, got </span><span class="s0">{</span><span class="s1">repr(base)</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">cls.__init__ = _no_init</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'runtime_checkable'</span><span class="s1">):</span>
    <span class="s1">runtime_checkable = typing.runtime_checkable</span>
<span class="s2"># 3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">runtime_checkable(cls):</span>
        <span class="s4">&quot;&quot;&quot;Mark a protocol class as a runtime protocol, so that it 
        can be used with isinstance() and issubclass(). Raise TypeError 
        if applied to a non-protocol class. 
 
        This allows a simple-minded structural check very similar to the 
        one-offs in collections.abc such as Hashable. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(cls</span><span class="s0">, </span><span class="s1">_ProtocolMeta) </span><span class="s0">or not </span><span class="s1">cls._is_protocol:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'@runtime_checkable can be only applied to protocol classes,'</span>
                            <span class="s3">f' got </span><span class="s0">{</span><span class="s1">cls</span><span class="s0">!r}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">cls._is_runtime_protocol = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">cls</span>


<span class="s2"># Exists for backwards compatibility.</span>
<span class="s1">runtime = runtime_checkable</span>


<span class="s2"># 3.8+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'SupportsIndex'</span><span class="s1">):</span>
    <span class="s1">SupportsIndex = typing.SupportsIndex</span>
<span class="s2"># 3.7</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@runtime_checkable</span>
    <span class="s0">class </span><span class="s1">SupportsIndex(Protocol):</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s1">@abc.abstractmethod</span>
        <span class="s0">def </span><span class="s1">__index__(self) -&gt; int:</span>
            <span class="s0">pass</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Required&quot;</span><span class="s1">):</span>
    <span class="s2"># The standard library TypedDict in Python 3.8 does not store runtime information</span>
    <span class="s2"># about which (if any) keys are optional.  See https://bugs.python.org/issue38834</span>
    <span class="s2"># The standard library TypedDict in Python 3.9.0/1 does not honour the &quot;total&quot;</span>
    <span class="s2"># keyword with old-style TypedDict().  See https://bugs.python.org/issue42059</span>
    <span class="s2"># The standard library TypedDict below Python 3.11 does not store runtime</span>
    <span class="s2"># information about optional and required keys when using Required or NotRequired.</span>
    <span class="s2"># Generic TypedDicts are also impossible using typing.TypedDict on Python &lt;3.11.</span>
    <span class="s1">TypedDict = typing.TypedDict</span>
    <span class="s1">_TypedDictMeta = typing._TypedDictMeta</span>
    <span class="s1">is_typeddict = typing.is_typeddict</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_check_fails(cls</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals[</span><span class="s3">'__name__'</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">[</span><span class="s3">'abc'</span><span class="s0">,</span>
                                                              <span class="s3">'functools'</span><span class="s0">,</span>
                                                              <span class="s3">'typing'</span><span class="s1">]:</span>
                <span class="s2"># Typed dicts are only for static structural subtyping.</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict does not support instance and class checks'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">pass</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_dict_new(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict.__new__(): not enough arguments'</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;cls&quot; keyword be passed</span>
        <span class="s0">return </span><span class="s1">dict(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">_dict_new.__text_signature__ = </span><span class="s3">'($cls, _typename, _fields=None, /, **kwargs)'</span>

    <span class="s0">def </span><span class="s1">_typeddict_new(*args</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict.__new__(): not enough arguments'</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;cls&quot; keyword be passed</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s1">typename</span><span class="s0">, </span><span class="s1">args = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># allow the &quot;_typename&quot; keyword be passed</span>
        <span class="s0">elif </span><span class="s3">'_typename' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">typename = kwargs.pop(</span><span class="s3">'_typename'</span><span class="s1">)</span>
            <span class="s0">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;Passing '_typename' as keyword argument is deprecated&quot;</span><span class="s0">,</span>
                          <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;TypedDict.__new__() missing 1 required positional &quot;</span>
                            <span class="s3">&quot;argument: '_typename'&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">fields</span><span class="s0">, </span><span class="s1">= args  </span><span class="s2"># allow the &quot;_fields&quot; keyword be passed</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">'TypedDict.__new__() takes from 2 to 3 '</span>
                                <span class="s3">f'positional arguments but </span><span class="s0">{</span><span class="s1">len(args) + </span><span class="s5">2</span><span class="s0">} </span><span class="s3">'</span>
                                <span class="s3">'were given'</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s3">'_fields' </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">len(kwargs) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fields = kwargs.pop(</span><span class="s3">'_fields'</span><span class="s1">)</span>
            <span class="s0">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;Passing '_fields' as keyword argument is deprecated&quot;</span><span class="s0">,</span>
                          <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fields = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">fields </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fields = kwargs</span>
        <span class="s0">elif </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
                            <span class="s3">&quot; but not both&quot;</span><span class="s1">)</span>

        <span class="s1">ns = {</span><span class="s3">'__annotations__'</span><span class="s1">: dict(fields)}</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Setting correct module is necessary to make typed dict classes pickleable.</span>
            <span class="s1">ns[</span><span class="s3">'__module__'</span><span class="s1">] = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">pass</span>

        <span class="s0">return </span><span class="s1">_TypedDictMeta(typename</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=total)</span>

    <span class="s1">_typeddict_new.__text_signature__ = (</span><span class="s3">'($cls, _typename, _fields=None,'</span>
                                         <span class="s3">' /, *, total=True, **kwargs)'</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">_TypedDictMeta(type):</span>
        <span class="s0">def </span><span class="s1">__init__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">super().__init__(name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns)</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s2"># Create new typed dict class object.</span>
            <span class="s2"># This method is called directly when TypedDict is subclassed,</span>
            <span class="s2"># or via _typeddict_new when TypedDict is instantiated. This way</span>
            <span class="s2"># TypedDict supports all three syntaxes described in its docstring.</span>
            <span class="s2"># Subclasses and instances of TypedDict return actual dictionaries</span>
            <span class="s2"># via _dict_new.</span>
            <span class="s1">ns[</span><span class="s3">'__new__'</span><span class="s1">] = _typeddict_new </span><span class="s0">if </span><span class="s1">name == </span><span class="s3">'TypedDict' </span><span class="s0">else </span><span class="s1">_dict_new</span>
            <span class="s2"># Don't insert typing.Generic into __bases__ here,</span>
            <span class="s2"># or Generic.__init_subclass__ will raise TypeError</span>
            <span class="s2"># in the super().__new__() call.</span>
            <span class="s2"># Instead, monkey-patch __bases__ onto the class after it's been created.</span>
            <span class="s1">tp_dict = super().__new__(cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ns)</span>

            <span class="s0">if </span><span class="s1">any(issubclass(base</span><span class="s0">, </span><span class="s1">typing.Generic) </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases):</span>
                <span class="s1">tp_dict.__bases__ = (typing.Generic</span><span class="s0">, </span><span class="s1">dict)</span>
                <span class="s1">_maybe_adjust_parameters(tp_dict)</span>

            <span class="s1">annotations = {}</span>
            <span class="s1">own_annotations = ns.get(</span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">msg = </span><span class="s3">&quot;TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
            <span class="s1">own_annotations = {</span>
                <span class="s1">n: typing._type_check(tp</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">own_annotations.items()</span>
            <span class="s1">}</span>
            <span class="s1">required_keys = set()</span>
            <span class="s1">optional_keys = set()</span>

            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">annotations.update(base.__dict__.get(</span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{}))</span>
                <span class="s1">required_keys.update(base.__dict__.get(</span><span class="s3">'__required_keys__'</span><span class="s0">, </span><span class="s1">()))</span>
                <span class="s1">optional_keys.update(base.__dict__.get(</span><span class="s3">'__optional_keys__'</span><span class="s0">, </span><span class="s1">()))</span>

            <span class="s1">annotations.update(own_annotations)</span>
            <span class="s0">for </span><span class="s1">annotation_key</span><span class="s0">, </span><span class="s1">annotation_type </span><span class="s0">in </span><span class="s1">own_annotations.items():</span>
                <span class="s1">annotation_origin = get_origin(annotation_type)</span>
                <span class="s0">if </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">Annotated:</span>
                    <span class="s1">annotation_args = get_args(annotation_type)</span>
                    <span class="s0">if </span><span class="s1">annotation_args:</span>
                        <span class="s1">annotation_type = annotation_args[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">annotation_origin = get_origin(annotation_type)</span>

                <span class="s0">if </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">Required:</span>
                    <span class="s1">required_keys.add(annotation_key)</span>
                <span class="s0">elif </span><span class="s1">annotation_origin </span><span class="s0">is </span><span class="s1">NotRequired:</span>
                    <span class="s1">optional_keys.add(annotation_key)</span>
                <span class="s0">elif </span><span class="s1">total:</span>
                    <span class="s1">required_keys.add(annotation_key)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">optional_keys.add(annotation_key)</span>

            <span class="s1">tp_dict.__annotations__ = annotations</span>
            <span class="s1">tp_dict.__required_keys__ = frozenset(required_keys)</span>
            <span class="s1">tp_dict.__optional_keys__ = frozenset(optional_keys)</span>
            <span class="s0">if not </span><span class="s1">hasattr(tp_dict</span><span class="s0">, </span><span class="s3">'__total__'</span><span class="s1">):</span>
                <span class="s1">tp_dict.__total__ = total</span>
            <span class="s0">return </span><span class="s1">tp_dict</span>

        <span class="s1">__instancecheck__ = __subclasscheck__ = _check_fails</span>

    <span class="s1">TypedDict = _TypedDictMeta(</span><span class="s3">'TypedDict'</span><span class="s0">, </span><span class="s1">(dict</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{})</span>
    <span class="s1">TypedDict.__module__ = __name__</span>
    <span class="s1">TypedDict.__doc__ = \</span>
        <span class="s3">&quot;&quot;&quot;A simple typed name space. At runtime it is equivalent to a plain dict. 
 
        TypedDict creates a dictionary type that expects all of its 
        instances to have a certain set of keys, with each key 
        associated with a value of a consistent type. This expectation 
        is not checked at runtime but is only enforced by type checkers. 
        Usage:: 
 
            class Point2D(TypedDict): 
                x: int 
                y: int 
                label: str 
 
            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK 
            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check 
 
            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first') 
 
        The type info can be accessed via the Point2D.__annotations__ dict, and 
        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets. 
        TypedDict supports two additional equivalent forms:: 
 
            Point2D = TypedDict('Point2D', x=int, y=int, label=str) 
            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str}) 
 
        The class syntax is only supported in Python 3.6+, while two other 
        syntax forms work for Python 2.7 and 3.2+ 
        &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;_TypedDictMeta&quot;</span><span class="s1">):</span>
        <span class="s1">_TYPEDDICT_TYPES = (typing._TypedDictMeta</span><span class="s0">, </span><span class="s1">_TypedDictMeta)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_TYPEDDICT_TYPES = (_TypedDictMeta</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">is_typeddict(tp):</span>
        <span class="s4">&quot;&quot;&quot;Check if an annotation is a TypedDict class 
 
        For example:: 
            class Film(TypedDict): 
                title: str 
                year: int 
 
            is_typeddict(Film)  # =&gt; True 
            is_typeddict(Union[list, str])  # =&gt; False 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">tuple(_TYPEDDICT_TYPES))</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;assert_type&quot;</span><span class="s1">):</span>
    <span class="s1">assert_type = typing.assert_type</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">assert_type(__val</span><span class="s0">, </span><span class="s1">__typ):</span>
        <span class="s4">&quot;&quot;&quot;Assert (to the type checker) that the value is of the given type. 
 
        When the type checker encounters a call to assert_type(), it 
        emits an error if the value is not of the specified type:: 
 
            def greet(name: str) -&gt; None: 
                assert_type(name, str)  # ok 
                assert_type(name, int)  # type checker error 
 
        At runtime this returns the first argument unchanged and otherwise 
        does nothing. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">__val</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Required&quot;</span><span class="s1">):</span>
    <span class="s1">get_type_hints = typing.get_type_hints</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">functools</span>
    <span class="s0">import </span><span class="s1">types</span>

    <span class="s2"># replaces _strip_annotations()</span>
    <span class="s0">def </span><span class="s1">_strip_extras(t):</span>
        <span class="s4">&quot;&quot;&quot;Strips Annotated, Required and NotRequired from a given type.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">_strip_extras(t.__origin__)</span>
        <span class="s0">if </span><span class="s1">hasattr(t</span><span class="s0">, </span><span class="s3">&quot;__origin__&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">t.__origin__ </span><span class="s0">in </span><span class="s1">(Required</span><span class="s0">, </span><span class="s1">NotRequired):</span>
            <span class="s0">return </span><span class="s1">_strip_extras(t.__args__[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">typing._GenericAlias):</span>
            <span class="s1">stripped_args = tuple(_strip_extras(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">t.copy_with(stripped_args)</span>
        <span class="s0">if </span><span class="s1">hasattr(types</span><span class="s0">, </span><span class="s3">&quot;GenericAlias&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">types.GenericAlias):</span>
            <span class="s1">stripped_args = tuple(_strip_extras(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">types.GenericAlias(t.__origin__</span><span class="s0">, </span><span class="s1">stripped_args)</span>
        <span class="s0">if </span><span class="s1">hasattr(types</span><span class="s0">, </span><span class="s3">&quot;UnionType&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">types.UnionType):</span>
            <span class="s1">stripped_args = tuple(_strip_extras(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">t.__args__)</span>
            <span class="s0">if </span><span class="s1">stripped_args == t.__args__:</span>
                <span class="s0">return </span><span class="s1">t</span>
            <span class="s0">return </span><span class="s1">functools.reduce(operator.or_</span><span class="s0">, </span><span class="s1">stripped_args)</span>

        <span class="s0">return </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">get_type_hints(obj</span><span class="s0">, </span><span class="s1">globalns=</span><span class="s0">None, </span><span class="s1">localns=</span><span class="s0">None, </span><span class="s1">include_extras=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Return type hints for an object. 
 
        This is often the same as obj.__annotations__, but it handles 
        forward references encoded as string literals, adds Optional[t] if a 
        default value equal to None is set and recursively replaces all 
        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T' 
        (unless 'include_extras=True'). 
 
        The argument may be a module, class, method, or function. The annotations 
        are returned as a dictionary. For classes, annotations include also 
        inherited members. 
 
        TypeError is raised if the argument is not of a type that can contain 
        annotations, and an empty dictionary is returned if no annotations are 
        present. 
 
        BEWARE -- the behavior of globalns and localns is counterintuitive 
        (unless you are familiar with how eval() and exec() work).  The 
        search order is locals first, then globals. 
 
        - If no dict arguments are passed, an attempt is made to use the 
          globals from obj (or the respective module's globals for classes), 
          and these are also used as the locals.  If the object does not appear 
          to have globals, an empty dictionary is used. 
 
        - If one dict argument is passed, it is used for both globals and 
          locals. 
 
        - If two dict arguments are passed, they specify globals and 
          locals, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Annotated&quot;</span><span class="s1">):</span>
            <span class="s1">hint = typing.get_type_hints(</span>
                <span class="s1">obj</span><span class="s0">, </span><span class="s1">globalns=globalns</span><span class="s0">, </span><span class="s1">localns=localns</span><span class="s0">, </span><span class="s1">include_extras=</span><span class="s0">True</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hint = typing.get_type_hints(obj</span><span class="s0">, </span><span class="s1">globalns=globalns</span><span class="s0">, </span><span class="s1">localns=localns)</span>
        <span class="s0">if </span><span class="s1">include_extras:</span>
            <span class="s0">return </span><span class="s1">hint</span>
        <span class="s0">return </span><span class="s1">{k: _strip_extras(t) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">hint.items()}</span>


<span class="s2"># Python 3.9+ has PEP 593 (Annotated)</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Annotated'</span><span class="s1">):</span>
    <span class="s1">Annotated = typing.Annotated</span>
    <span class="s2"># Not exported and not a public API, but needed for get_origin() and get_args()</span>
    <span class="s2"># to work.</span>
    <span class="s1">_AnnotatedAlias = typing._AnnotatedAlias</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_AnnotatedAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Runtime representation of an annotated type. 
 
        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't' 
        with extra annotations. The alias behaves like a normal typing alias, 
        instantiating is the same as instantiating the underlying type, binding 
        it to types is also the same. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">metadata):</span>
            <span class="s0">if </span><span class="s1">isinstance(origin</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
                <span class="s1">metadata = origin.__metadata__ + metadata</span>
                <span class="s1">origin = origin.__origin__</span>
            <span class="s1">super().__init__(origin</span><span class="s0">, </span><span class="s1">origin)</span>
            <span class="s1">self.__metadata__ = metadata</span>

        <span class="s0">def </span><span class="s1">copy_with(self</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">assert </span><span class="s1">len(params) == </span><span class="s5">1</span>
            <span class="s1">new_type = params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias(new_type</span><span class="s0">, </span><span class="s1">self.__metadata__)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">f&quot;typing_extensions.Annotated[</span><span class="s0">{</span><span class="s1">typing._type_repr(self.__origin__)</span><span class="s0">}</span><span class="s3">, &quot;</span>
                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s3">', '</span><span class="s1">.join(repr(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self.__metadata__)</span><span class="s0">}</span><span class="s3">]&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">operator.getitem</span><span class="s0">, </span><span class="s1">(</span>
                <span class="s1">Annotated</span><span class="s0">, </span><span class="s1">(self.__origin__</span><span class="s0">,</span><span class="s1">) + self.__metadata__</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">if </span><span class="s1">self.__origin__ != other.__origin__:</span>
                <span class="s0">return False</span>
            <span class="s0">return </span><span class="s1">self.__metadata__ == other.__metadata__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((self.__origin__</span><span class="s0">, </span><span class="s1">self.__metadata__))</span>

    <span class="s0">class </span><span class="s1">Annotated:</span>
        <span class="s4">&quot;&quot;&quot;Add context specific metadata to a type. 
 
        Example: Annotated[int, runtime_check.Unsigned] indicates to the 
        hypothetical runtime_check module that this type is an unsigned int. 
        Every other consumer of this type can ignore this metadata and treat 
        this type as int. 
 
        The first argument to Annotated must be a valid type (and will be in 
        the __origin__ field), the remaining arguments are kept as a tuple in 
        the __extra__ field. 
 
        Details: 
 
        - It's an error to call `Annotated` with less than two arguments. 
        - Nested Annotated are flattened:: 
 
            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3] 
 
        - Instantiating an annotated type is equivalent to instantiating the 
        underlying type:: 
 
            Annotated[C, Ann1](5) == C(5) 
 
        - Annotated can be used as a generic type alias:: 
 
            Optimized = Annotated[T, runtime.Optimize()] 
            Optimized[int] == Annotated[int, runtime.Optimize()] 
 
            OptimizedList = Annotated[List[T], runtime.Optimize()] 
            OptimizedList[int] == Annotated[List[int], runtime.Optimize()] 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="s1">)</span>

        <span class="s1">@typing._tp_cache</span>
        <span class="s0">def </span><span class="s1">__class_getitem__(cls</span><span class="s0">, </span><span class="s1">params):</span>
            <span class="s0">if not </span><span class="s1">isinstance(params</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">or </span><span class="s1">len(params) &lt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Annotated[...] should be used &quot;</span>
                                <span class="s3">&quot;with at least two arguments (a type and an &quot;</span>
                                <span class="s3">&quot;annotation).&quot;</span><span class="s1">)</span>
            <span class="s1">allowed_special_forms = (ClassVar</span><span class="s0">, </span><span class="s1">Final)</span>
            <span class="s0">if </span><span class="s1">get_origin(params[</span><span class="s5">0</span><span class="s1">]) </span><span class="s0">in </span><span class="s1">allowed_special_forms:</span>
                <span class="s1">origin = params[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
                <span class="s1">origin = typing._type_check(params[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">metadata = tuple(params[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s0">return </span><span class="s1">_AnnotatedAlias(origin</span><span class="s0">, </span><span class="s1">metadata)</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s3">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">cls.__module__</span><span class="s0">}</span><span class="s3">.Annotated&quot;</span>
            <span class="s1">)</span>

<span class="s2"># Python 3.8 has get_origin() and get_args() but those implementations aren't</span>
<span class="s2"># Annotated-aware, so we can't use those. Python 3.9's versions don't support</span>
<span class="s2"># ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.</span>
<span class="s0">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
    <span class="s1">get_origin = typing.get_origin</span>
    <span class="s1">get_args = typing.get_args</span>
<span class="s2"># 3.7-3.9</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">_BaseGenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">_BaseGenericAlias = typing._GenericAlias</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># 3.9+</span>
        <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">GenericAlias </span><span class="s0">as </span><span class="s1">_typing_GenericAlias</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">_typing_GenericAlias = typing._GenericAlias</span>

    <span class="s0">def </span><span class="s1">get_origin(tp):</span>
        <span class="s4">&quot;&quot;&quot;Get the unsubscripted version of a type. 
 
        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar 
        and Annotated. Return None for unsupported types. Examples:: 
 
            get_origin(Literal[42]) is Literal 
            get_origin(int) is None 
            get_origin(ClassVar[int]) is ClassVar 
            get_origin(Generic) is Generic 
            get_origin(Generic[T]) is Generic 
            get_origin(Union[T, int]) is Union 
            get_origin(List[Tuple[T, T]][int]) == list 
            get_origin(P.args) is P 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">Annotated</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_typing_GenericAlias</span><span class="s0">, </span><span class="s1">_BaseGenericAlias</span><span class="s0">,</span>
                           <span class="s1">ParamSpecArgs</span><span class="s0">, </span><span class="s1">ParamSpecKwargs)):</span>
            <span class="s0">return </span><span class="s1">tp.__origin__</span>
        <span class="s0">if </span><span class="s1">tp </span><span class="s0">is </span><span class="s1">typing.Generic:</span>
            <span class="s0">return </span><span class="s1">typing.Generic</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_args(tp):</span>
        <span class="s4">&quot;&quot;&quot;Get type arguments with all substitutions performed. 
 
        For unions, basic simplifications used by Union constructor are performed. 
        Examples:: 
            get_args(Dict[str, int]) == (str, int) 
            get_args(int) == () 
            get_args(Union[int, Union[T, int], str][int]) == (int, str) 
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int]) 
            get_args(Callable[[], T][int]) == ([], int) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">_AnnotatedAlias):</span>
            <span class="s0">return </span><span class="s1">(tp.__origin__</span><span class="s0">,</span><span class="s1">) + tp.__metadata__</span>
        <span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_typing_GenericAlias)):</span>
            <span class="s0">if </span><span class="s1">getattr(tp</span><span class="s0">, </span><span class="s3">&quot;_special&quot;</span><span class="s0">, False</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">()</span>
            <span class="s1">res = tp.__args__</span>
            <span class="s0">if </span><span class="s1">get_origin(tp) </span><span class="s0">is </span><span class="s1">collections.abc.Callable </span><span class="s0">and </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">Ellipsis:</span>
                <span class="s1">res = (list(res[:-</span><span class="s5">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">res[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">return </span><span class="s1">()</span>


<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'TypeAlias'</span><span class="s1">):</span>
    <span class="s1">TypeAlias = typing.TypeAlias</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeAliasForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_TypeAliasForm</span>
    <span class="s0">def </span><span class="s1">TypeAlias(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;Special marker indicating that an assignment should 
        be recognized as a proper type alias definition by type 
        checkers. 
 
        For example:: 
 
            Predicate: TypeAlias = Callable[..., bool] 
 
        It's invalid when used anywhere except as in the example above. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_TypeAliasForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">TypeAlias = _TypeAliasForm(</span><span class="s3">'TypeAlias'</span><span class="s0">,</span>
                               <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;Special marker indicating that an assignment should 
                               be recognized as a proper type alias definition by type 
                               checkers. 
 
                               For example:: 
 
                                   Predicate: TypeAlias = Callable[..., bool] 
 
                               It's invalid when used anywhere except as in the example 
                               above.&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">_DefaultMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin for TypeVarLike defaults.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">default):</span>
        <span class="s0">if </span><span class="s1">isinstance(default</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
            <span class="s1">self.__default__ = tuple((typing._type_check(d</span><span class="s0">, </span><span class="s3">&quot;Default must be a type&quot;</span><span class="s1">)</span>
                                      <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">default))</span>
        <span class="s0">elif </span><span class="s1">default:</span>
            <span class="s1">self.__default__ = typing._type_check(default</span><span class="s0">, </span><span class="s3">&quot;Default must be a type&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.__default__ = </span><span class="s0">None</span>


<span class="s2"># Add default and infer_variance parameters from PEP 696 and 695</span>
<span class="s0">class </span><span class="s1">TypeVar(typing.TypeVar</span><span class="s0">, </span><span class="s1">_DefaultMixin</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Type variable.&quot;&quot;&quot;</span>

    <span class="s1">__module__ = </span><span class="s3">'typing'</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*constraints</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None,</span>
                 <span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False,</span>
                 <span class="s1">default=</span><span class="s0">None, </span><span class="s1">infer_variance=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(name</span><span class="s0">, </span><span class="s1">*constraints</span><span class="s0">, </span><span class="s1">bound=bound</span><span class="s0">, </span><span class="s1">covariant=covariant</span><span class="s0">,</span>
                         <span class="s1">contravariant=contravariant)</span>
        <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>
        <span class="s1">self.__infer_variance__ = infer_variance</span>

        <span class="s2"># for pickling:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">def_mod = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s1">def_mod = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
            <span class="s1">self.__module__ = def_mod</span>


<span class="s2"># Python 3.10+ has PEP 612</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'ParamSpecArgs'</span><span class="s1">):</span>
    <span class="s1">ParamSpecArgs = typing.ParamSpecArgs</span>
    <span class="s1">ParamSpecKwargs = typing.ParamSpecKwargs</span>
<span class="s2"># 3.7-3.9</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_Immutable:</span>
        <span class="s4">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>
        <span class="s1">__slots__ = ()</span>

        <span class="s0">def </span><span class="s1">__copy__(self):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__deepcopy__(self</span><span class="s0">, </span><span class="s1">memo):</span>
            <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">class </span><span class="s1">ParamSpecArgs(_Immutable):</span>
        <span class="s4">&quot;&quot;&quot;The args for a ParamSpec object. 
 
        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs. 
 
        ParamSpecArgs objects have a reference back to their ParamSpec: 
 
        P.args.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin):</span>
            <span class="s1">self.__origin__ = origin</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.__origin__.__name__</span><span class="s0">}</span><span class="s3">.args&quot;</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ParamSpecArgs):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self.__origin__ == other.__origin__</span>

    <span class="s0">class </span><span class="s1">ParamSpecKwargs(_Immutable):</span>
        <span class="s4">&quot;&quot;&quot;The kwargs for a ParamSpec object. 
 
        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs. 
 
        ParamSpecKwargs objects have a reference back to their ParamSpec: 
 
        P.kwargs.__origin__ is P 
 
        This type is meant for runtime introspection and has no special meaning to 
        static type checkers. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin):</span>
            <span class="s1">self.__origin__ = origin</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.__origin__.__name__</span><span class="s0">}</span><span class="s3">.kwargs&quot;</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ParamSpecKwargs):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s0">return </span><span class="s1">self.__origin__ == other.__origin__</span>

<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'ParamSpec'</span><span class="s1">):</span>

    <span class="s2"># Add default Parameter - PEP 696</span>
    <span class="s0">class </span><span class="s1">ParamSpec(typing.ParamSpec</span><span class="s0">, </span><span class="s1">_DefaultMixin</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Parameter specification variable.&quot;&quot;&quot;</span>

        <span class="s1">__module__ = </span><span class="s3">'typing'</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None, </span><span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False,</span>
                     <span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">super().__init__(name</span><span class="s0">, </span><span class="s1">bound=bound</span><span class="s0">, </span><span class="s1">covariant=covariant</span><span class="s0">,</span>
                             <span class="s1">contravariant=contravariant)</span>
            <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>

            <span class="s2"># for pickling:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">def_mod = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s1">def_mod = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

<span class="s2"># 3.7-3.9</span>
<span class="s0">else</span><span class="s1">:</span>

    <span class="s2"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">ParamSpec(list</span><span class="s0">, </span><span class="s1">_DefaultMixin):</span>
        <span class="s4">&quot;&quot;&quot;Parameter specification variable. 
 
        Usage:: 
 
           P = ParamSpec('P') 
 
        Parameter specification variables exist primarily for the benefit of static 
        type checkers.  They are used to forward the parameter types of one 
        callable to another callable, a pattern commonly found in higher order 
        functions and decorators.  They are only valid when used in ``Concatenate``, 
        or s the first argument to ``Callable``. In Python 3.10 and higher, 
        they are also supported in user-defined Generics at runtime. 
        See class Generic for more information on generic types.  An 
        example for annotating a decorator:: 
 
           T = TypeVar('T') 
           P = ParamSpec('P') 
 
           def add_logging(f: Callable[P, T]) -&gt; Callable[P, T]: 
               '''A type-safe decorator to add logging to a function.''' 
               def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T: 
                   logging.info(f'{f.__name__} was called') 
                   return f(*args, **kwargs) 
               return inner 
 
           @add_logging 
           def add_two(x: float, y: float) -&gt; float: 
               '''Add two numbers together.''' 
               return x + y 
 
        Parameter specification variables defined with covariant=True or 
        contravariant=True can be used to declare covariant or contravariant 
        generic types.  These keyword arguments are valid, but their actual semantics 
        are yet to be decided.  See PEP 612 for details. 
 
        Parameter specification variables can be introspected. e.g.: 
 
           P.__name__ == 'T' 
           P.__bound__ == None 
           P.__covariant__ == False 
           P.__contravariant__ == False 
 
        Note that only parameter specification variables defined in global scope can 
        be pickled. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ = typing.TypeVar</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">args(self):</span>
            <span class="s0">return </span><span class="s1">ParamSpecArgs(self)</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">kwargs(self):</span>
            <span class="s0">return </span><span class="s1">ParamSpecKwargs(self)</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">bound=</span><span class="s0">None, </span><span class="s1">covariant=</span><span class="s0">False, </span><span class="s1">contravariant=</span><span class="s0">False,</span>
                     <span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">super().__init__([self])</span>
            <span class="s1">self.__name__ = name</span>
            <span class="s1">self.__covariant__ = bool(covariant)</span>
            <span class="s1">self.__contravariant__ = bool(contravariant)</span>
            <span class="s0">if </span><span class="s1">bound:</span>
                <span class="s1">self.__bound__ = typing._type_check(bound</span><span class="s0">, </span><span class="s3">'Bound must be a type.'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.__bound__ = </span><span class="s0">None</span>
            <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>

            <span class="s2"># for pickling:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">def_mod = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s1">def_mod = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">if </span><span class="s1">self.__covariant__:</span>
                <span class="s1">prefix = </span><span class="s3">'+'</span>
            <span class="s0">elif </span><span class="s1">self.__contravariant__:</span>
                <span class="s1">prefix = </span><span class="s3">'-'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">prefix = </span><span class="s3">'~'</span>
            <span class="s0">return </span><span class="s1">prefix + self.__name__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">object.__hash__(self)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s2"># Hack to get typing._type_check to pass.</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">pass</span>


<span class="s2"># 3.7-3.9</span>
<span class="s0">if not </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Concatenate'</span><span class="s1">):</span>
    <span class="s2"># Inherits from list as a workaround for Callable checks in Python &lt; 3.9.2.</span>
    <span class="s0">class </span><span class="s1">_ConcatenateGenericAlias(list):</span>

        <span class="s2"># Trick Generic into looking into this for __parameters__.</span>
        <span class="s1">__class__ = typing._GenericAlias</span>

        <span class="s2"># Flag in 3.8.</span>
        <span class="s1">_special = </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">origin</span><span class="s0">, </span><span class="s1">args):</span>
            <span class="s1">super().__init__(args)</span>
            <span class="s1">self.__origin__ = origin</span>
            <span class="s1">self.__args__ = args</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s1">_type_repr = typing._type_repr</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">_type_repr(self.__origin__)</span><span class="s0">}</span><span class="s3">'</span>
                    <span class="s3">f'[</span><span class="s0">{</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(_type_repr(arg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self.__args__)</span><span class="s0">}</span><span class="s3">]'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">hash((self.__origin__</span><span class="s0">, </span><span class="s1">self.__args__))</span>

        <span class="s2"># Hack to get typing._type_check to pass in Generic.</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">pass</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">__parameters__(self):</span>
            <span class="s0">return </span><span class="s1">tuple(</span>
                <span class="s1">tp </span><span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">self.__args__ </span><span class="s0">if </span><span class="s1">isinstance(tp</span><span class="s0">, </span><span class="s1">(typing.TypeVar</span><span class="s0">, </span><span class="s1">ParamSpec))</span>
            <span class="s1">)</span>


<span class="s2"># 3.7-3.9</span>
<span class="s1">@typing._tp_cache</span>
<span class="s0">def </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters):</span>
    <span class="s0">if </span><span class="s1">parameters == ():</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(parameters</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">parameters = (parameters</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">isinstance(parameters[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ParamSpec):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;The last parameter to Concatenate should be a &quot;</span>
                        <span class="s3">&quot;ParamSpec variable.&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
    <span class="s1">parameters = tuple(typing._type_check(p</span><span class="s0">, </span><span class="s1">msg) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parameters)</span>
    <span class="s0">return </span><span class="s1">_ConcatenateGenericAlias(self</span><span class="s0">, </span><span class="s1">parameters)</span>


<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Concatenate'</span><span class="s1">):</span>
    <span class="s1">Concatenate = typing.Concatenate</span>
    <span class="s1">_ConcatenateGenericAlias = typing._ConcatenateGenericAlias </span><span class="s2"># noqa</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s1">@_TypeAliasForm</span>
    <span class="s0">def </span><span class="s1">Concatenate(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>
<span class="s2"># 3.7-8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_ConcatenateForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s0">return </span><span class="s1">_concatenate_getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>

    <span class="s1">Concatenate = _ConcatenateForm(</span>
        <span class="s3">'Concatenate'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a 
        higher order function which adds, removes or transforms parameters of a 
        callable. 
 
        For example:: 
 
           Callable[Concatenate[int, P], int] 
 
        See PEP 612 for detailed information. 
        &quot;&quot;&quot;</span><span class="s1">)</span>

<span class="s2"># 3.10+</span>
<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'TypeGuard'</span><span class="s1">):</span>
    <span class="s1">TypeGuard = typing.TypeGuard</span>
<span class="s2"># 3.9</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_TypeGuardForm</span>
    <span class="s0">def </span><span class="s1">TypeGuard(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>
<span class="s2"># 3.7-3.8</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_TypeGuardForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">TypeGuard = _TypeGuardForm(</span>
        <span class="s3">'TypeGuard'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;Special typing form used to annotate the return type of a user-defined 
        type guard function.  ``TypeGuard`` only accepts a single type argument. 
        At runtime, functions marked this way should return a boolean. 
 
        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static 
        type checkers to determine a more precise type of an expression within a 
        program's code flow.  Usually type narrowing is done by analyzing 
        conditional code flow and applying the narrowing to a block of code.  The 
        conditional expression here is sometimes referred to as a &quot;type guard&quot;. 
 
        Sometimes it would be convenient to use a user-defined boolean function 
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its 
        return type to alert static type checkers to this intention. 
 
        Using  ``-&gt; TypeGuard`` tells the static type checker that for a given 
        function: 
 
        1. The return value is a boolean. 
        2. If the return value is ``True``, the type of its argument 
        is the type inside ``TypeGuard``. 
 
        For example:: 
 
            def is_str(val: Union[str, float]): 
                # &quot;isinstance&quot; type guard 
                if isinstance(val, str): 
                    # Type of ``val`` is narrowed to ``str`` 
                    ... 
                else: 
                    # Else, type of ``val`` is narrowed to ``float``. 
                    ... 
 
        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower 
        form of ``TypeA`` (it can even be a wider form) and this may lead to 
        type-unsafe results.  The main reason is to allow for things like 
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not 
        a subtype of the former, since ``List`` is invariant.  The responsibility of 
        writing type-safe type guards is left to the user. 
 
        ``TypeGuard`` also works with type variables.  For more information, see 
        PEP 647 (User-Defined Type Guards). 
        &quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s2"># Vendored from cpython typing._SpecialFrom</span>
<span class="s0">class </span><span class="s1">_SpecialForm(typing._Final</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s1">__slots__ = (</span><span class="s3">'_name'</span><span class="s0">, </span><span class="s3">'__doc__'</span><span class="s0">, </span><span class="s3">'_getitem'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">getitem):</span>
        <span class="s1">self._getitem = getitem</span>
        <span class="s1">self._name = getitem.__name__</span>
        <span class="s1">self.__doc__ = getitem.__doc__</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s1">{</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__qualname__'</span><span class="s1">}:</span>
            <span class="s0">return </span><span class="s1">self._name</span>

        <span class="s0">raise </span><span class="s1">AttributeError(item)</span>

    <span class="s0">def </span><span class="s1">__mro_entries__(self</span><span class="s0">, </span><span class="s1">bases):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot subclass </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s3">f'typing_extensions.</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">}</span><span class="s3">'</span>

    <span class="s0">def </span><span class="s1">__reduce__(self):</span>
        <span class="s0">return </span><span class="s1">self._name</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot instantiate </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__or__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">typing.Union[self</span><span class="s0">, </span><span class="s1">other]</span>

    <span class="s0">def </span><span class="s1">__ror__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">typing.Union[other</span><span class="s0">, </span><span class="s1">self]</span>

    <span class="s0">def </span><span class="s1">__instancecheck__(self</span><span class="s0">, </span><span class="s1">obj):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">cannot be used with isinstance()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__subclasscheck__(self</span><span class="s0">, </span><span class="s1">cls):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">cannot be used with issubclass()&quot;</span><span class="s1">)</span>

    <span class="s1">@typing._tp_cache</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s0">return </span><span class="s1">self._getitem(self</span><span class="s0">, </span><span class="s1">parameters)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;LiteralString&quot;</span><span class="s1">):</span>
    <span class="s1">LiteralString = typing.LiteralString</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">LiteralString(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s4">&quot;&quot;&quot;Represents an arbitrary literal string. 
 
        Example:: 
 
          from pip._vendor.typing_extensions import LiteralString 
 
          def query(sql: LiteralString) -&gt; ...: 
              ... 
 
          query(&quot;SELECT * FROM table&quot;)  # ok 
          query(f&quot;SELECT * FROM {input()}&quot;)  # not ok 
 
        See PEP 675 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Self&quot;</span><span class="s1">):</span>
    <span class="s1">Self = typing.Self</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Self(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s4">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes. 
 
        Example:: 
 
          from typing import Self 
 
          class ReturnsSelf: 
              def parse(self, data: bytes) -&gt; Self: 
                  ... 
                  return self 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Never&quot;</span><span class="s1">):</span>
    <span class="s1">Never = typing.Never</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">@_SpecialForm</span>
    <span class="s0">def </span><span class="s1">Never(self</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s4">&quot;&quot;&quot;The bottom type, a type that has no members. 
 
        This can be used to define a function that should never be 
        called, or a function that never returns:: 
 
            from pip._vendor.typing_extensions import Never 
 
            def never_call_me(arg: Never) -&gt; None: 
                pass 
 
            def int_or_str(arg: int | str) -&gt; None: 
                never_call_me(arg)  # type checker error 
                match arg: 
                    case int(): 
                        print(&quot;It's an int&quot;) 
                    case str(): 
                        print(&quot;It's a str&quot;) 
                    case _: 
                        never_call_me(arg)  # ok, arg is of type Never 
 
        &quot;&quot;&quot;</span>

        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not subscriptable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'Required'</span><span class="s1">):</span>
    <span class="s1">Required = typing.Required</span>
    <span class="s1">NotRequired = typing.NotRequired</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_ExtensionsSpecialForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s1">@_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">Required(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">@_ExtensionsSpecialForm</span>
    <span class="s0">def </span><span class="s1">NotRequired(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_RequiredForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">typing._GenericAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Required = _RequiredForm(</span>
        <span class="s3">'Required'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to mark a key of a total=False TypedDict 
        as required. For example: 
 
            class Movie(TypedDict, total=False): 
                title: Required[str] 
                year: int 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
 
        There is no runtime checking that a required key is actually provided 
        when instantiating a related TypedDict. 
        &quot;&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">NotRequired = _RequiredForm(</span>
        <span class="s3">'NotRequired'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to mark a key of a TypedDict as 
        potentially missing. For example: 
 
            class Movie(TypedDict): 
                title: str 
                year: NotRequired[int] 
 
            m = Movie( 
                title='The Matrix',  # typechecker error if key is omitted 
                year=1999, 
            ) 
        &quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;Unpack&quot;</span><span class="s1">):  </span><span class="s2"># 3.11+</span>
    <span class="s1">Unpack = typing.Unpack</span>
<span class="s0">elif </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
    <span class="s0">class </span><span class="s1">_UnpackSpecialForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

    <span class="s0">class </span><span class="s1">_UnpackAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">__class__ = typing.TypeVar</span>

    <span class="s1">@_UnpackSpecialForm</span>
    <span class="s0">def </span><span class="s1">Unpack(self</span><span class="s0">, </span><span class="s1">parameters):</span>
        <span class="s4">&quot;&quot;&quot;A special typing construct to unpack a variadic type. For example: 
 
            Shape = TypeVarTuple('Shape') 
            Batch = NewType('Batch', int) 
 
            def add_batch_axis( 
                x: Array[Unpack[Shape]] 
            ) -&gt; Array[Batch, Unpack[Shape]]: ... 
 
        &quot;&quot;&quot;</span>
        <span class="s1">item = typing._type_check(parameters</span><span class="s0">, </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">_UnpackAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">_is_unpack(obj):</span>
        <span class="s0">return </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">_UnpackAlias)</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">_UnpackAlias(typing._GenericAlias</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">__class__ = typing.TypeVar</span>

    <span class="s0">class </span><span class="s1">_UnpackForm(typing._SpecialForm</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s3">'typing_extensions.' </span><span class="s1">+ self._name</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">parameters):</span>
            <span class="s1">item = typing._type_check(parameters</span><span class="s0">,</span>
                                      <span class="s3">f'</span><span class="s0">{</span><span class="s1">self._name</span><span class="s0">} </span><span class="s3">accepts only a single type.'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">_UnpackAlias(self</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s1">Unpack = _UnpackForm(</span>
        <span class="s3">'Unpack'</span><span class="s0">,</span>
        <span class="s1">doc=</span><span class="s3">&quot;&quot;&quot;A special typing construct to unpack a variadic type. For example: 
 
            Shape = TypeVarTuple('Shape') 
            Batch = NewType('Batch', int) 
 
            def add_batch_axis( 
                x: Array[Unpack[Shape]] 
            ) -&gt; Array[Batch, Unpack[Shape]]: ... 
 
        &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_is_unpack(obj):</span>
        <span class="s0">return </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">_UnpackAlias)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeVarTuple&quot;</span><span class="s1">):  </span><span class="s2"># 3.11+</span>

    <span class="s2"># Add default Parameter - PEP 696</span>
    <span class="s0">class </span><span class="s1">TypeVarTuple(typing.TypeVarTuple</span><span class="s0">, </span><span class="s1">_DefaultMixin</span><span class="s0">, </span><span class="s1">_root=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Type variable tuple.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">super().__init__(name)</span>
            <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>

            <span class="s2"># for pickling:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">def_mod = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s1">def_mod = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">class </span><span class="s1">TypeVarTuple(_DefaultMixin):</span>
        <span class="s4">&quot;&quot;&quot;Type variable tuple. 
 
        Usage:: 
 
            Ts = TypeVarTuple('Ts') 
 
        In the same way that a normal type variable is a stand-in for a single 
        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple* 
        type such as ``Tuple[int, str]``. 
 
        Type variable tuples can be used in ``Generic`` declarations. 
        Consider the following example:: 
 
            class Array(Generic[*Ts]): ... 
 
        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``, 
        where ``T1`` and ``T2`` are type variables. To use these type variables 
        as type parameters of ``Array``, we must *unpack* the type variable tuple using 
        the star operator: ``*Ts``. The signature of ``Array`` then behaves 
        as if we had simply written ``class Array(Generic[T1, T2]): ...``. 
        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows 
        us to parameterise the class with an *arbitrary* number of type parameters. 
 
        Type variable tuples can be used anywhere a normal ``TypeVar`` can. 
        This includes class definitions, as shown above, as well as function 
        signatures and variable annotations:: 
 
            class Array(Generic[*Ts]): 
 
                def __init__(self, shape: Tuple[*Ts]): 
                    self._shape: Tuple[*Ts] = shape 
 
                def get_shape(self) -&gt; Tuple[*Ts]: 
                    return self._shape 
 
            shape = (Height(480), Width(640)) 
            x: Array[Height, Width] = Array(shape) 
            y = abs(x)  # Inferred type is Array[Height, Width] 
            z = x + x   #        ...    is Array[Height, Width] 
            x.get_shape()  #     ...    is tuple[Height, Width] 
 
        &quot;&quot;&quot;</span>

        <span class="s2"># Trick Generic __parameters__.</span>
        <span class="s1">__class__ = typing.TypeVar</span>

        <span class="s0">def </span><span class="s1">__iter__(self):</span>
            <span class="s0">yield </span><span class="s1">self.__unpacked__</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">self.__name__ = name</span>
            <span class="s1">_DefaultMixin.__init__(self</span><span class="s0">, </span><span class="s1">default)</span>

            <span class="s2"># for pickling:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">def_mod = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
                <span class="s1">def_mod = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">def_mod != </span><span class="s3">'typing_extensions'</span><span class="s1">:</span>
                <span class="s1">self.__module__ = def_mod</span>

            <span class="s1">self.__unpacked__ = Unpack[self]</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s0">def </span><span class="s1">__hash__(self):</span>
            <span class="s0">return </span><span class="s1">object.__hash__(self)</span>

        <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">return </span><span class="s1">self </span><span class="s0">is </span><span class="s1">other</span>

        <span class="s0">def </span><span class="s1">__reduce__(self):</span>
            <span class="s0">return </span><span class="s1">self.__name__</span>

        <span class="s0">def </span><span class="s1">__init_subclass__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
            <span class="s0">if </span><span class="s3">'_root' </span><span class="s0">not in </span><span class="s1">kwds:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot subclass special typing classes&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;reveal_type&quot;</span><span class="s1">):</span>
    <span class="s1">reveal_type = typing.reveal_type</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">reveal_type(__obj: T) -&gt; T:</span>
        <span class="s4">&quot;&quot;&quot;Reveal the inferred type of a variable. 
 
        When a static type checker encounters a call to ``reveal_type()``, 
        it will emit the inferred type of the argument:: 
 
            x: int = 1 
            reveal_type(x) 
 
        Running a static type checker (e.g., ``mypy``) on this example 
        will produce output similar to 'Revealed type is &quot;builtins.int&quot;'. 
 
        At runtime, the function prints the runtime type of the 
        argument and returns it unchanged. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">print(</span><span class="s3">f&quot;Runtime type is </span><span class="s0">{</span><span class="s1">type(__obj).__name__</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s0">, </span><span class="s1">file=sys.stderr)</span>
        <span class="s0">return </span><span class="s1">__obj</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;assert_never&quot;</span><span class="s1">):</span>
    <span class="s1">assert_never = typing.assert_never</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">assert_never(__arg: Never) -&gt; Never:</span>
        <span class="s4">&quot;&quot;&quot;Assert to the type checker that a line of code is unreachable. 
 
        Example:: 
 
            def int_or_str(arg: int | str) -&gt; None: 
                match arg: 
                    case int(): 
                        print(&quot;It's an int&quot;) 
                    case str(): 
                        print(&quot;It's a str&quot;) 
                    case _: 
                        assert_never(arg) 
 
        If a type checker finds that a call to assert_never() is 
        reachable, it will emit an error. 
 
        At runtime, this throws an exception when called. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">AssertionError(</span><span class="s3">&quot;Expected code to be unreachable&quot;</span><span class="s1">)</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">'dataclass_transform'</span><span class="s1">):</span>
    <span class="s1">dataclass_transform = typing.dataclass_transform</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">dataclass_transform(</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">eq_default: bool = </span><span class="s0">True,</span>
        <span class="s1">order_default: bool = </span><span class="s0">False,</span>
        <span class="s1">kw_only_default: bool = </span><span class="s0">False,</span>
        <span class="s1">field_specifiers: typing.Tuple[</span>
            <span class="s1">typing.Union[typing.Type[typing.Any]</span><span class="s0">, </span><span class="s1">typing.Callable[...</span><span class="s0">, </span><span class="s1">typing.Any]]</span><span class="s0">,</span>
            <span class="s1">...</span>
        <span class="s1">] = ()</span><span class="s0">,</span>
        <span class="s1">**kwargs: typing.Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; typing.Callable[[T]</span><span class="s0">, </span><span class="s1">T]:</span>
        <span class="s4">&quot;&quot;&quot;Decorator that marks a function, class, or metaclass as providing 
        dataclass-like behavior. 
 
        Example: 
 
            from pip._vendor.typing_extensions import dataclass_transform 
 
            _T = TypeVar(&quot;_T&quot;) 
 
            # Used on a decorator function 
            @dataclass_transform() 
            def create_model(cls: type[_T]) -&gt; type[_T]: 
                ... 
                return cls 
 
            @create_model 
            class CustomerModel: 
                id: int 
                name: str 
 
            # Used on a base class 
            @dataclass_transform() 
            class ModelBase: ... 
 
            class CustomerModel(ModelBase): 
                id: int 
                name: str 
 
            # Used on a metaclass 
            @dataclass_transform() 
            class ModelMeta(type): ... 
 
            class ModelBase(metaclass=ModelMeta): ... 
 
            class CustomerModel(ModelBase): 
                id: int 
                name: str 
 
        Each of the ``CustomerModel`` classes defined in this example will now 
        behave similarly to a dataclass created with the ``@dataclasses.dataclass`` 
        decorator. For example, the type checker will synthesize an ``__init__`` 
        method. 
 
        The arguments to this decorator can be used to customize this behavior: 
        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be 
          True or False if it is omitted by the caller. 
        - ``order_default`` indicates whether the ``order`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is 
          assumed to be True or False if it is omitted by the caller. 
        - ``field_specifiers`` specifies a static list of supported classes 
          or functions that describe fields, similar to ``dataclasses.field()``. 
 
        At runtime, this decorator records its arguments in the 
        ``__dataclass_transform__`` attribute on the decorated object. 
 
        See PEP 681 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">decorator(cls_or_fn):</span>
            <span class="s1">cls_or_fn.__dataclass_transform__ = {</span>
                <span class="s3">&quot;eq_default&quot;</span><span class="s1">: eq_default</span><span class="s0">,</span>
                <span class="s3">&quot;order_default&quot;</span><span class="s1">: order_default</span><span class="s0">,</span>
                <span class="s3">&quot;kw_only_default&quot;</span><span class="s1">: kw_only_default</span><span class="s0">,</span>
                <span class="s3">&quot;field_specifiers&quot;</span><span class="s1">: field_specifiers</span><span class="s0">,</span>
                <span class="s3">&quot;kwargs&quot;</span><span class="s1">: kwargs</span><span class="s0">,</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">cls_or_fn</span>
        <span class="s0">return </span><span class="s1">decorator</span>


<span class="s0">if </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;override&quot;</span><span class="s1">):</span>
    <span class="s1">override = typing.override</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">_F = typing.TypeVar(</span><span class="s3">&quot;_F&quot;</span><span class="s0">, </span><span class="s1">bound=typing.Callable[...</span><span class="s0">, </span><span class="s1">typing.Any])</span>

    <span class="s0">def </span><span class="s1">override(__arg: _F) -&gt; _F:</span>
        <span class="s4">&quot;&quot;&quot;Indicate that a method is intended to override a method in a base class. 
 
        Usage: 
 
            class Base: 
                def method(self) -&gt; None: ... 
                    pass 
 
            class Child(Base): 
                @override 
                def method(self) -&gt; None: 
                    super().method() 
 
        When this decorator is applied to a method, the type checker will 
        validate that it overrides a method with the same name on a base class. 
        This helps prevent bugs that may occur when a base class is changed 
        without an equivalent change to a child class. 
 
        See PEP 698 for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">__arg</span>


<span class="s2"># We have to do some monkey patching to deal with the dual nature of</span>
<span class="s2"># Unpack/TypeVarTuple:</span>
<span class="s2"># - We want Unpack to be a kind of TypeVar so it gets accepted in</span>
<span class="s2">#   Generic[Unpack[Ts]]</span>
<span class="s2"># - We want it to *not* be treated as a TypeVar for the purposes of</span>
<span class="s2">#   counting generic parameters, so that when we subscript a generic,</span>
<span class="s2">#   the runtime doesn't try to substitute the Unpack with the subscripted type.</span>
<span class="s0">if not </span><span class="s1">hasattr(typing</span><span class="s0">, </span><span class="s3">&quot;TypeVarTuple&quot;</span><span class="s1">):</span>
    <span class="s1">typing._collect_type_vars = _collect_type_vars</span>
    <span class="s1">typing._check_generic = _check_generic</span>


<span class="s2"># Backport typing.NamedTuple as it exists in Python 3.11.</span>
<span class="s2"># In 3.11, the ability to define generic `NamedTuple`s was supported.</span>
<span class="s2"># This was explicitly disallowed in 3.9-3.10, and only half-worked in &lt;=3.8.</span>
<span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">11</span><span class="s1">):</span>
    <span class="s1">NamedTuple = typing.NamedTuple</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s0">def </span><span class="s1">_caller():</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">sys._getframe(</span><span class="s5">2</span><span class="s1">).f_globals.get(</span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__main__'</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):  </span><span class="s2"># For platforms without _getframe()</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">_make_nmtuple(name</span><span class="s0">, </span><span class="s1">types</span><span class="s0">, </span><span class="s1">module</span><span class="s0">, </span><span class="s1">defaults=()):</span>
        <span class="s1">fields = [n </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types]</span>
        <span class="s1">annotations = {n: typing._type_check(t</span><span class="s0">, </span><span class="s3">f&quot;field </span><span class="s0">{</span><span class="s1">n</span><span class="s0">} </span><span class="s3">annotation must be a type&quot;</span><span class="s1">)</span>
                       <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">types}</span>
        <span class="s1">nm_tpl = collections.namedtuple(name</span><span class="s0">, </span><span class="s1">fields</span><span class="s0">,</span>
                                        <span class="s1">defaults=defaults</span><span class="s0">, </span><span class="s1">module=module)</span>
        <span class="s1">nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = annotations</span>
        <span class="s2"># The `_field_types` attribute was removed in 3.9;</span>
        <span class="s2"># in earlier versions, it is the same as the `__annotations__` attribute</span>
        <span class="s0">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">9</span><span class="s1">):</span>
            <span class="s1">nm_tpl._field_types = annotations</span>
        <span class="s0">return </span><span class="s1">nm_tpl</span>

    <span class="s1">_prohibited_namedtuple_fields = typing._prohibited</span>
    <span class="s1">_special_namedtuple_fields = frozenset({</span><span class="s3">'__module__'</span><span class="s0">, </span><span class="s3">'__name__'</span><span class="s0">, </span><span class="s3">'__annotations__'</span><span class="s1">})</span>

    <span class="s0">class </span><span class="s1">_NamedTupleMeta(type):</span>
        <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">typename</span><span class="s0">, </span><span class="s1">bases</span><span class="s0">, </span><span class="s1">ns):</span>
            <span class="s0">assert </span><span class="s1">_NamedTuple </span><span class="s0">in </span><span class="s1">bases</span>
            <span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s0">if </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">_NamedTuple </span><span class="s0">and </span><span class="s1">base </span><span class="s0">is not </span><span class="s1">typing.Generic:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">'can only inherit from a NamedTuple type and Generic'</span><span class="s1">)</span>
            <span class="s1">bases = tuple(tuple </span><span class="s0">if </span><span class="s1">base </span><span class="s0">is </span><span class="s1">_NamedTuple </span><span class="s0">else </span><span class="s1">base </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">bases)</span>
            <span class="s1">types = ns.get(</span><span class="s3">'__annotations__'</span><span class="s0">, </span><span class="s1">{})</span>
            <span class="s1">default_names = []</span>
            <span class="s0">for </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">types:</span>
                <span class="s0">if </span><span class="s1">field_name </span><span class="s0">in </span><span class="s1">ns:</span>
                    <span class="s1">default_names.append(field_name)</span>
                <span class="s0">elif </span><span class="s1">default_names:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Non-default namedtuple field </span><span class="s0">{</span><span class="s1">field_name</span><span class="s0">} </span><span class="s3">&quot;</span>
                                    <span class="s3">f&quot;cannot follow default field&quot;</span>
                                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s3">'s' </span><span class="s0">if </span><span class="s1">len(default_names) &gt; </span><span class="s5">1 </span><span class="s0">else </span><span class="s3">''</span><span class="s0">} </span><span class="s3">&quot;</span>
                                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s3">', '</span><span class="s1">.join(default_names)</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">nm_tpl = _make_nmtuple(</span>
                <span class="s1">typename</span><span class="s0">, </span><span class="s1">types.items()</span><span class="s0">,</span>
                <span class="s1">defaults=[ns[n] </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">default_names]</span><span class="s0">,</span>
                <span class="s1">module=ns[</span><span class="s3">'__module__'</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">nm_tpl.__bases__ = bases</span>
            <span class="s0">if </span><span class="s1">typing.Generic </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">class_getitem = typing.Generic.__class_getitem__.__func__</span>
                <span class="s1">nm_tpl.__class_getitem__ = classmethod(class_getitem)</span>
            <span class="s2"># update from user namespace without overriding special namedtuple attributes</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">ns:</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">_prohibited_namedtuple_fields:</span>
                    <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;Cannot overwrite NamedTuple attribute &quot; </span><span class="s1">+ key)</span>
                <span class="s0">elif </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">_special_namedtuple_fields </span><span class="s0">and </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">nm_tpl._fields:</span>
                    <span class="s1">setattr(nm_tpl</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">ns[key])</span>
            <span class="s0">if </span><span class="s1">typing.Generic </span><span class="s0">in </span><span class="s1">bases:</span>
                <span class="s1">nm_tpl.__init_subclass__()</span>
            <span class="s0">return </span><span class="s1">nm_tpl</span>

    <span class="s0">def </span><span class="s1">NamedTuple(__typename</span><span class="s0">, </span><span class="s1">__fields=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">__fields </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">__fields = kwargs.items()</span>
        <span class="s0">elif </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Either list of fields or keywords&quot;</span>
                            <span class="s3">&quot; can be provided to NamedTuple, not both&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">_make_nmtuple(__typename</span><span class="s0">, </span><span class="s1">__fields</span><span class="s0">, </span><span class="s1">module=_caller())</span>

    <span class="s1">NamedTuple.__doc__ = typing.NamedTuple.__doc__</span>
    <span class="s1">_NamedTuple = type.__new__(_NamedTupleMeta</span><span class="s0">, </span><span class="s3">'NamedTuple'</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">{})</span>

    <span class="s2"># On 3.8+, alter the signature so that it matches typing.NamedTuple.</span>
    <span class="s2"># The signature of typing.NamedTuple on &gt;=3.8 is invalid syntax in Python 3.7,</span>
    <span class="s2"># so just leave the signature as it is on 3.7.</span>
    <span class="s0">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">):</span>
        <span class="s1">NamedTuple.__text_signature__ = </span><span class="s3">'(typename, fields=None, /, **kwargs)'</span>

    <span class="s0">def </span><span class="s1">_namedtuple_mro_entries(bases):</span>
        <span class="s0">assert </span><span class="s1">NamedTuple </span><span class="s0">in </span><span class="s1">bases</span>
        <span class="s0">return </span><span class="s1">(_NamedTuple</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">NamedTuple.__mro_entries__ = _namedtuple_mro_entries</span>
</pre>
</body>
</html>